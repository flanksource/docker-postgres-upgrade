package generators

import (
	"fmt"
	"reflect"
	"sort"
	"strings"

	"github.com/flanksource/postgres/pkg"
)

// ConfigGenerator generates YAML configuration files
type ConfigGenerator struct {
	conf *pkg.PgconfigSchemaJson
}

// NewConfigGenerator creates a new configuration generator
func NewConfigGenerator(conf *pkg.PgconfigSchemaJson) *ConfigGenerator {
	return &ConfigGenerator{conf: conf}
}

// GenerateFullYAML generates a complete YAML configuration file with all options, descriptions, and defaults
func (g *ConfigGenerator) GenerateFullYAML() (string, error) {
	var sb strings.Builder

	sb.WriteString("# PGConfig - PostgreSQL Configuration Management\n")
	sb.WriteString("# This file contains all available configuration options with their defaults and descriptions\n")
	sb.WriteString("# Generated by pgconfig\n\n")

	// Generate PostgreSQL configuration
	if g.conf.Postgres != nil {
		if err := g.generateSectionYAML(&sb, "postgres", reflect.TypeOf(*g.conf.Postgres), reflect.ValueOf(*g.conf.Postgres), 0); err != nil {
			return "", fmt.Errorf("failed to generate postgres section: %w", err)
		}
	}

	// Generate PgBouncer configuration
	if g.conf.Pgbouncer != nil {
		if err := g.generateSectionYAML(&sb, "pgbouncer", reflect.TypeOf(*g.conf.Pgbouncer), reflect.ValueOf(*g.conf.Pgbouncer), 0); err != nil {
			return "", fmt.Errorf("failed to generate pgbouncer section: %w", err)
		}
	}

	// Generate WalG configuration
	if g.conf.Walg != nil {
		if err := g.generateSectionYAML(&sb, "walg", reflect.TypeOf(*g.conf.Walg), reflect.ValueOf(*g.conf.Walg), 0); err != nil {
			return "", fmt.Errorf("failed to generate walg section: %w", err)
		}
	}

	// Generate PostgREST configuration
	if g.conf.Postgrest != nil {
		if err := g.generateSectionYAML(&sb, "postgrest", reflect.TypeOf(*g.conf.Postgrest), reflect.ValueOf(*g.conf.Postgrest), 0); err != nil {
			return "", fmt.Errorf("failed to generate postgrest section: %w", err)
		}
	}

	// Generate PGAudit configuration
	if g.conf.Pgaudit != nil {
		if err := g.generateSectionYAML(&sb, "pgaudit", reflect.TypeOf(*g.conf.Pgaudit), reflect.ValueOf(*g.conf.Pgaudit), 0); err != nil {
			return "", fmt.Errorf("failed to generate pgaudit section: %w", err)
		}
	}

	return sb.String(), nil
}

// GenerateMinimalYAML generates a YAML file with only non-default values
func (g *ConfigGenerator) GenerateMinimalYAML() (string, error) {
	var sb strings.Builder

	sb.WriteString("# PGConfig - PostgreSQL Configuration Management (Minimal)\n")
	sb.WriteString("# This file contains only non-default configuration values\n")
	sb.WriteString("# Generated by pgconfig\n\n")

	defaults := pkg.GetAllDefaults()

	// Generate minimal sections only if they have non-default values
	if g.conf.Postgres != nil && hasNonDefaults(reflect.ValueOf(*g.conf.Postgres), reflect.TypeOf(*g.conf.Postgres), defaults, "postgres") {
		if err := g.generateMinimalSectionYAML(&sb, "postgres", reflect.TypeOf(*g.conf.Postgres), reflect.ValueOf(*g.conf.Postgres), defaults, "postgres", 0); err != nil {
			return "", fmt.Errorf("failed to generate minimal postgres section: %w", err)
		}
	}

	if g.conf.Pgbouncer != nil && hasNonDefaults(reflect.ValueOf(*g.conf.Pgbouncer), reflect.TypeOf(*g.conf.Pgbouncer), defaults, "pgbouncer") {
		if err := g.generateMinimalSectionYAML(&sb, "pgbouncer", reflect.TypeOf(*g.conf.Pgbouncer), reflect.ValueOf(*g.conf.Pgbouncer), defaults, "pgbouncer", 0); err != nil {
			return "", fmt.Errorf("failed to generate minimal pgbouncer section: %w", err)
		}
	}

	if g.conf.Walg != nil && hasNonDefaults(reflect.ValueOf(*g.conf.Walg), reflect.TypeOf(*g.conf.Walg), defaults, "walg") {
		if err := g.generateMinimalSectionYAML(&sb, "walg", reflect.TypeOf(*g.conf.Walg), reflect.ValueOf(*g.conf.Walg), defaults, "walg", 0); err != nil {
			return "", fmt.Errorf("failed to generate minimal walg section: %w", err)
		}
	}

	if g.conf.Postgrest != nil && hasNonDefaults(reflect.ValueOf(*g.conf.Postgrest), reflect.TypeOf(*g.conf.Postgrest), defaults, "postgrest") {
		if err := g.generateMinimalSectionYAML(&sb, "postgrest", reflect.TypeOf(*g.conf.Postgrest), reflect.ValueOf(*g.conf.Postgrest), defaults, "postgrest", 0); err != nil {
			return "", fmt.Errorf("failed to generate minimal postgrest section: %w", err)
		}
	}

	if g.conf.Pgaudit != nil && hasNonDefaults(reflect.ValueOf(*g.conf.Pgaudit), reflect.TypeOf(*g.conf.Pgaudit), defaults, "pgaudit") {
		if err := g.generateMinimalSectionYAML(&sb, "pgaudit", reflect.TypeOf(*g.conf.Pgaudit), reflect.ValueOf(*g.conf.Pgaudit), defaults, "pgaudit", 0); err != nil {
			return "", fmt.Errorf("failed to generate minimal pgaudit section: %w", err)
		}
	}

	result := sb.String()
	if strings.TrimSpace(result) == strings.TrimSpace("# PGConfig - PostgreSQL Configuration Management (Minimal)\n# This file contains only non-default configuration values\n# Generated by pgconfig") {
		return "# PGConfig - PostgreSQL Configuration Management (Minimal)\n# This file contains only non-default configuration values\n# Generated by pgconfig\n\n# All values are currently at their defaults\n{}\n", nil
	}

	return result, nil
}

func (g *ConfigGenerator) generateSectionYAML(sb *strings.Builder, sectionName string, typ reflect.Type, val reflect.Value, indent int) error {
	indentStr := strings.Repeat("  ", indent)

	sb.WriteString(fmt.Sprintf("%s# %s Configuration\n", indentStr, strings.Title(sectionName)))
	sb.WriteString(fmt.Sprintf("%s%s:\n", indentStr, sectionName))

	return g.generateFieldsYAML(sb, typ, val, indent+1, true)
}

func (g *ConfigGenerator) generateMinimalSectionYAML(sb *strings.Builder, sectionName string, typ reflect.Type, val reflect.Value, defaults map[string]string, prefix string, indent int) error {
	indentStr := strings.Repeat("  ", indent)

	sb.WriteString(fmt.Sprintf("%s# %s Configuration (non-defaults only)\n", indentStr, strings.Title(sectionName)))
	sb.WriteString(fmt.Sprintf("%s%s:\n", indentStr, sectionName))

	return g.generateMinimalFieldsYAML(sb, typ, val, defaults, prefix, indent+1)
}

func (g *ConfigGenerator) generateFieldsYAML(sb *strings.Builder, typ reflect.Type, val reflect.Value, indent int, includeDefaults bool) error {
	indentStr := strings.Repeat("  ", indent)

	// Get all fields and sort them
	var fields []reflect.StructField
	for i := 0; i < typ.NumField(); i++ {
		field := typ.Field(i)
		if field.PkgPath == "" { // exported field
			fields = append(fields, field)
		}
	}

	// Sort fields by name for consistent output
	sort.Slice(fields, func(i, j int) bool {
		return fields[i].Name < fields[j].Name
	})

	for _, field := range fields {
		fieldVal := val.FieldByName(field.Name)
		if !fieldVal.IsValid() {
			continue
		}

		koanfTag := field.Tag.Get("koanf")
		if koanfTag == "" {
			continue
		}

		// Handle nested structs
		if field.Type.Kind() == reflect.Struct {
			sb.WriteString(fmt.Sprintf("\n%s# %s\n", indentStr, field.Name))
			sb.WriteString(fmt.Sprintf("%s%s:\n", indentStr, koanfTag))
			if err := g.generateFieldsYAML(sb, field.Type, fieldVal, indent+1, includeDefaults); err != nil {
				return err
			}
			continue
		}

		// Handle slices
		if field.Type.Kind() == reflect.Slice {
			sb.WriteString(fmt.Sprintf("\n%s# %s\n", indentStr, field.Name))
			sb.WriteString(fmt.Sprintf("%s%s: []\n", indentStr, koanfTag))
			continue
		}

		// Get field description and default
		description := g.getFieldDescription(field)
		defaultVal := field.Tag.Get("default")
		envVar := field.Tag.Get("env")

		// Add description comment
		if description != "" {
			sb.WriteString(fmt.Sprintf("\n%s# %s\n", indentStr, description))
		}

		// Add additional info
		var info []string
		if defaultVal != "" {
			info = append(info, fmt.Sprintf("default: %s", defaultVal))
		}
		if envVar != "" {
			info = append(info, fmt.Sprintf("env: %s", envVar))
		}
		if len(info) > 0 {
			sb.WriteString(fmt.Sprintf("%s# %s\n", indentStr, strings.Join(info, ", ")))
		}

		// Add the field value
		currentVal := g.formatFieldValue(fieldVal, defaultVal)
		if includeDefaults || currentVal != defaultVal {
			sb.WriteString(fmt.Sprintf("%s%s: %s\n", indentStr, koanfTag, currentVal))
		} else {
			sb.WriteString(fmt.Sprintf("%s# %s: %s\n", indentStr, koanfTag, currentVal))
		}
	}

	return nil
}

func (g *ConfigGenerator) generateMinimalFieldsYAML(sb *strings.Builder, typ reflect.Type, val reflect.Value, defaults map[string]string, prefix string, indent int) error {
	indentStr := strings.Repeat("  ", indent)

	// Get all fields and sort them
	var fields []reflect.StructField
	for i := 0; i < typ.NumField(); i++ {
		field := typ.Field(i)
		if field.PkgPath == "" { // exported field
			fields = append(fields, field)
		}
	}

	// Sort fields by name for consistent output
	sort.Slice(fields, func(i, j int) bool {
		return fields[i].Name < fields[j].Name
	})

	for _, field := range fields {
		fieldVal := val.FieldByName(field.Name)
		if !fieldVal.IsValid() {
			continue
		}

		koanfTag := field.Tag.Get("koanf")
		if koanfTag == "" {
			continue
		}

		fieldPath := prefix + "." + koanfTag

		// Handle nested structs
		if field.Type.Kind() == reflect.Struct {
			if hasNonDefaults(fieldVal, field.Type, defaults, fieldPath) {
				sb.WriteString(fmt.Sprintf("\n%s# %s (non-defaults only)\n", indentStr, field.Name))
				sb.WriteString(fmt.Sprintf("%s%s:\n", indentStr, koanfTag))
				if err := g.generateMinimalFieldsYAML(sb, field.Type, fieldVal, defaults, fieldPath, indent+1); err != nil {
					return err
				}
			}
			continue
		}

		// Handle slices
		if field.Type.Kind() == reflect.Slice && fieldVal.Len() > 0 {
			sb.WriteString(fmt.Sprintf("\n%s# %s\n", indentStr, field.Name))
			sb.WriteString(fmt.Sprintf("%s%s: []\n", indentStr, koanfTag))
			continue
		}

		// Check if this field has a non-default value
		currentVal := g.formatFieldValue(fieldVal, "")
		defaultVal, hasDefault := defaults[fieldPath]

		if !hasDefault || currentVal != defaultVal {
			// Add description comment
			description := g.getFieldDescription(field)
			if description != "" {
				sb.WriteString(fmt.Sprintf("\n%s# %s\n", indentStr, description))
			}

			sb.WriteString(fmt.Sprintf("%s%s: %s\n", indentStr, koanfTag, currentVal))
		}
	}

	return nil
}

func (g *ConfigGenerator) formatFieldValue(val reflect.Value, defaultVal string) string {
	switch val.Kind() {
	case reflect.String:
		str := val.String()
		if str == "" && defaultVal != "" {
			return fmt.Sprintf(`"%s"`, defaultVal)
		}
		return fmt.Sprintf(`"%s"`, str)
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return fmt.Sprintf("%d", val.Int())
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return fmt.Sprintf("%d", val.Uint())
	case reflect.Float32, reflect.Float64:
		return fmt.Sprintf("%.2f", val.Float())
	case reflect.Bool:
		return fmt.Sprintf("%t", val.Bool())
	default:
		return fmt.Sprintf(`"%v"`, val.Interface())
	}
}

func (g *ConfigGenerator) getFieldDescription(field reflect.StructField) string {
	// Simple fallback description for now
	return fmt.Sprintf("Configuration setting: %s", field.Name)
}

func hasNonDefaults(val reflect.Value, typ reflect.Type, defaults map[string]string, prefix string) bool {
	for i := 0; i < typ.NumField(); i++ {
		field := typ.Field(i)
		if field.PkgPath != "" { // skip unexported fields
			continue
		}

		koanfTag := field.Tag.Get("koanf")
		if koanfTag == "" {
			continue
		}

		fieldPath := prefix + "." + koanfTag
		fieldVal := val.Field(i)

		// Handle nested structs
		if field.Type.Kind() == reflect.Struct {
			if hasNonDefaults(fieldVal, field.Type, defaults, fieldPath) {
				return true
			}
			continue
		}

		// Handle slices
		if field.Type.Kind() == reflect.Slice && fieldVal.Len() > 0 {
			return true
		}

		// Check if this field has a non-default value
		currentVal := formatValue(fieldVal)
		if defaultVal, exists := defaults[fieldPath]; exists {
			if currentVal != defaultVal {
				return true
			}
		} else if !isZero(fieldVal) {
			return true
		}
	}

	return false
}

func formatValue(val reflect.Value) string {
	switch val.Kind() {
	case reflect.String:
		return val.String()
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return fmt.Sprintf("%d", val.Int())
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return fmt.Sprintf("%d", val.Uint())
	case reflect.Float32, reflect.Float64:
		return fmt.Sprintf("%.2f", val.Float())
	case reflect.Bool:
		return fmt.Sprintf("%t", val.Bool())
	default:
		return fmt.Sprintf("%v", val.Interface())
	}
}

func isZero(val reflect.Value) bool {
	zero := reflect.Zero(val.Type())
	return reflect.DeepEqual(val.Interface(), zero.Interface())
}
