{{/*
Enhanced ConfigMap for PostgreSQL configuration
*/}}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "postgres-upgrade.fullname" . }}-enhanced-config
  labels:
    {{- include "postgres-upgrade.labels" . | nindent 4 }}
    app.kubernetes.io/component: config
data:
  postgresql.conf: |
    # Enhanced PostgreSQL configuration
    # This file is included by the main postgresql.conf
    
    # Connection settings
    max_connections = {{ .Values.database.config.max_connections | default "200" }}
    
    # Memory settings
    {{- if .Values.database.config.shared_buffers }}
    shared_buffers = '{{ .Values.database.config.shared_buffers }}'
    {{- else }}
    shared_buffers = '128MB'
    {{- end }}
    
    {{- if .Values.database.config.effective_cache_size }}
    effective_cache_size = '{{ .Values.database.config.effective_cache_size }}'
    {{- else }}
    effective_cache_size = '512MB'
    {{- end }}
    
    {{- if .Values.database.config.work_mem }}
    work_mem = '{{ .Values.database.config.work_mem }}'
    {{- else }}
    work_mem = '4MB'
    {{- end }}
    
    {{- if .Values.database.config.maintenance_work_mem }}
    maintenance_work_mem = '{{ .Values.database.config.maintenance_work_mem }}'
    {{- else }}
    maintenance_work_mem = '64MB'
    {{- end }}
    
    # WAL settings
    wal_level = {{ .Values.database.config.wal_level | default "replica" }}
    max_wal_senders = {{ .Values.database.config.max_wal_senders | default "10" }}
    {{- if .Values.database.config.wal_keep_size }}
    wal_keep_size = '{{ .Values.database.config.wal_keep_size }}'
    {{- else }}
    wal_keep_size = '1GB'
    {{- end }}
    
    {{- if .Values.backup.enabled }}
    # WAL archiving for backup
    archive_mode = on
    archive_command = 'wal-g wal-push %p'
    archive_timeout = 300
    {{- end }}
    
    # Performance tuning
    random_page_cost = {{ .Values.database.config.random_page_cost | default "1.1" }}
    effective_io_concurrency = {{ .Values.database.config.effective_io_concurrency | default "200" }}
    checkpoint_completion_target = {{ .Values.database.config.checkpoint_completion_target | default "0.9" }}
    
    # Extensions configuration
    {{- if .Values.database.extensions.enabled }}
    shared_preload_libraries = 'pg_cron'
    cron.database_name = '{{ .Values.database.name }}'
    {{- end }}
    
    # Logging
    log_min_messages = warning
    log_min_error_statement = error
    log_min_duration_statement = 1000
    log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
    
    # Custom configuration
    {{- range $key, $value := .Values.database.config.custom }}
    {{ $key }} = {{ $value | quote }}
    {{- end }}
  
  init-extensions.sql: |
    -- Initialize PostgreSQL extensions for enhanced image
    
    -- Create extensions schema for better organization
    CREATE SCHEMA IF NOT EXISTS extensions;
    GRANT USAGE ON SCHEMA extensions TO public;
    
    {{- if .Values.database.extensions.enabled }}
    {{- range .Values.database.extensions.list }}
    {{- if eq . "pgvector" }}
    CREATE EXTENSION IF NOT EXISTS pgvector WITH SCHEMA extensions;
    {{- else if eq . "pg_cron" }}
    CREATE EXTENSION IF NOT EXISTS pg_cron WITH SCHEMA extensions;
    {{- else if eq . "pgjwt" }}
    CREATE EXTENSION IF NOT EXISTS pgjwt WITH SCHEMA extensions;
    {{- else if eq . "pg_hashids" }}
    CREATE EXTENSION IF NOT EXISTS pg_hashids WITH SCHEMA extensions;
    {{- else if eq . "hypopg" }}
    CREATE EXTENSION IF NOT EXISTS hypopg WITH SCHEMA extensions;
    {{- else if eq . "pgcrypto" }}
    CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA extensions;
    {{- else }}
    CREATE EXTENSION IF NOT EXISTS {{ . }};
    {{- end }}
    {{- end }}
    {{- end }}
    
    {{- if .Values.postgrest.enabled }}
    -- Create basic roles for PostgREST
    DO $$
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = '{{ .Values.postgrest.config.dbAnonRole }}') THEN
            CREATE ROLE {{ .Values.postgrest.config.dbAnonRole }} NOLOGIN;
        END IF;
        
        IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'authenticated') THEN
            CREATE ROLE authenticated NOLOGIN;
        END IF;
        
        IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'service_role') THEN
            CREATE ROLE service_role NOLOGIN;
        END IF;
    END
    $$;
    
    -- Grant basic permissions
    GRANT USAGE ON SCHEMA {{ .Values.postgrest.config.dbSchema }} TO {{ .Values.postgrest.config.dbAnonRole }}, authenticated, service_role;
    GRANT USAGE ON SCHEMA extensions TO {{ .Values.postgrest.config.dbAnonRole }}, authenticated, service_role;
    GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA extensions TO {{ .Values.postgrest.config.dbAnonRole }}, authenticated, service_role;
    {{- end }}
    
    -- Create a health check function
    CREATE OR REPLACE FUNCTION public.health_check()
    RETURNS json
    LANGUAGE sql
    STABLE
    AS $$
        SELECT json_build_object(
            'status', 'healthy',
            'timestamp', now(),
            'version', version(),
            'extensions', (
                SELECT json_agg(extname ORDER BY extname)
                FROM pg_extension
            )
        );
    $$;
    
    {{- if .Values.postgrest.enabled }}
    GRANT EXECUTE ON FUNCTION public.health_check() TO {{ .Values.postgrest.config.dbAnonRole }};
    {{- end }}
    
    -- Create a simple metrics table for demonstration
    CREATE TABLE IF NOT EXISTS public.metrics (
        id SERIAL PRIMARY KEY,
        name TEXT NOT NULL,
        value NUMERIC,
        timestamp TIMESTAMPTZ DEFAULT now()
    );
    
    {{- if .Values.postgrest.enabled }}
    GRANT SELECT ON public.metrics TO {{ .Values.postgrest.config.dbAnonRole }};
    GRANT ALL ON public.metrics TO authenticated, service_role;
    GRANT USAGE ON SEQUENCE public.metrics_id_seq TO authenticated, service_role;
    {{- end }}