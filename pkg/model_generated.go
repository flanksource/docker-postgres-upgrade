// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package pkg

import (
	"encoding/json"
	"github.com/flanksource/postgres/pkg/types"
)
import "fmt"
import "reflect"
import "regexp"

// Database connection configuration for PgBouncer
type DatabaseConfig struct {
	// Query to run on new connections
	ConnectQuery *string `json:"connect_query,omitempty" yaml:"connect_query,omitempty" mapstructure:"connect_query,omitempty"`

	// Database name
	Dbname *string `json:"dbname,omitempty" yaml:"dbname,omitempty" mapstructure:"dbname,omitempty"`

	// Database host
	Host string `json:"host,omitempty" yaml:"host,omitempty" mapstructure:"host,omitempty"`

	// Database password
	Password *string `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`

	// Pool size for this database
	PoolSize *int `json:"pool_size,omitempty" yaml:"pool_size,omitempty" mapstructure:"pool_size,omitempty"`

	// Database port
	Port int `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`

	// Database user
	User *string `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DatabaseConfig) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain DatabaseConfig
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["host"]; !ok || v == nil {
		plain.Host = "localhost"
	}
	if plain.PoolSize != nil && 1 > *plain.PoolSize {
		return fmt.Errorf("field %s: must be >= %v", "pool_size", 1)
	}
	if v, ok := raw["port"]; !ok || v == nil {
		plain.Port = 5432.0
	}
	if 65535 < plain.Port {
		return fmt.Errorf("field %s: must be <= %v", "port", 65535)
	}
	if 1 > plain.Port {
		return fmt.Errorf("field %s: must be >= %v", "port", 1)
	}
	*j = DatabaseConfig(plain)
	return nil
}

// PGAudit extension configuration for PostgreSQL audit logging
type PGAuditConf struct {
	// Specifies whether audit logging should be filtered using role-based access
	// control
	FilterUsingRole PGAuditConfFilterUsingRole `json:"filter_using_role,omitempty" yaml:"filter_using_role,omitempty" mapstructure:"filter_using_role,omitempty"`

	// Specifies which classes of statements will be logged by session audit logging
	Log PGAuditConfLog `json:"log,omitempty" yaml:"log,omitempty" mapstructure:"log,omitempty"`

	// Specifies that session logging should be enabled in the case where all
	// relations in a statement are in pg_catalog
	LogCatalog PGAuditConfLogCatalog `json:"log_catalog,omitempty" yaml:"log_catalog,omitempty" mapstructure:"log_catalog,omitempty"`

	// Specifies whether log messages will be visible to a client process
	LogClient PGAuditConfLogClient `json:"log_client,omitempty" yaml:"log_client,omitempty" mapstructure:"log_client,omitempty"`

	// Specifies the log level that will be used for log entries
	LogLevel PGAuditConfLogLevel `json:"log_level,omitempty" yaml:"log_level,omitempty" mapstructure:"log_level,omitempty"`

	// Specifies that audit logging should include the parameters that were passed
	// with the statement
	LogParameter PGAuditConfLogParameter `json:"log_parameter,omitempty" yaml:"log_parameter,omitempty" mapstructure:"log_parameter,omitempty"`

	// Sets the maximum size of a parameter value that will be logged
	LogParameterMaxSize string `json:"log_parameter_max_size,omitempty" yaml:"log_parameter_max_size,omitempty" mapstructure:"log_parameter_max_size,omitempty"`

	// Specifies whether session audit logging should create a separate log entry for
	// each relation referenced in a SELECT or DML statement
	LogRelation PGAuditConfLogRelation `json:"log_relation,omitempty" yaml:"log_relation,omitempty" mapstructure:"log_relation,omitempty"`

	// Specifies whether logging will include the statement text and parameters (if
	// enabled)
	LogStatement PGAuditConfLogStatement `json:"log_statement,omitempty" yaml:"log_statement,omitempty" mapstructure:"log_statement,omitempty"`

	// Specifies whether logging will include the statement text and parameters (if
	// enabled) with the first log entry for a statement/substatement combination or
	// with every log entry
	LogStatementOnce PGAuditConfLogStatementOnce `json:"log_statement_once,omitempty" yaml:"log_statement_once,omitempty" mapstructure:"log_statement_once,omitempty"`

	// Sets the maximum stack depth for audit logging to prevent infinite recursion
	MaxStackDepth *types.Size `json:"max_stack_depth,omitempty" yaml:"max_stack_depth,omitempty" mapstructure:"max_stack_depth,omitempty"`

	// Specifies which classes of statements will be logged by object audit logging
	ObjectLog PGAuditConfObjectLog `json:"object_log,omitempty" yaml:"object_log,omitempty" mapstructure:"object_log,omitempty"`

	// Specifies that object logging should be enabled in the case where all relations
	// in a statement are in pg_catalog
	ObjectLogCatalog PGAuditConfObjectLogCatalog `json:"object_log_catalog,omitempty" yaml:"object_log_catalog,omitempty" mapstructure:"object_log_catalog,omitempty"`

	// Specifies the master role to use for object audit logging
	Role *string `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`

	// Specifies whether the statement name, if provided, should be included in the
	// session log
	SessionLogStatementName PGAuditConfSessionLogStatementName `json:"session_log_statement_name,omitempty" yaml:"session_log_statement_name,omitempty" mapstructure:"session_log_statement_name,omitempty"`
}

type PGAuditConfFilterUsingRole string

const PGAuditConfFilterUsingRoleOff PGAuditConfFilterUsingRole = "off"
const PGAuditConfFilterUsingRoleOn PGAuditConfFilterUsingRole = "on"

var enumValues_PGAuditConfFilterUsingRole = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfFilterUsingRole) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfFilterUsingRole {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfFilterUsingRole, v)
	}
	*j = PGAuditConfFilterUsingRole(v)
	return nil
}

type PGAuditConfLog string

const PGAuditConfLogAll PGAuditConfLog = "all"

type PGAuditConfLogCatalog string

const PGAuditConfLogCatalogOff PGAuditConfLogCatalog = "off"
const PGAuditConfLogCatalogOn PGAuditConfLogCatalog = "on"

var enumValues_PGAuditConfLogCatalog = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLogCatalog) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLogCatalog {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLogCatalog, v)
	}
	*j = PGAuditConfLogCatalog(v)
	return nil
}

type PGAuditConfLogClient string

const PGAuditConfLogClientOff PGAuditConfLogClient = "off"
const PGAuditConfLogClientOn PGAuditConfLogClient = "on"

var enumValues_PGAuditConfLogClient = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLogClient) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLogClient {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLogClient, v)
	}
	*j = PGAuditConfLogClient(v)
	return nil
}

const PGAuditConfLogDdl PGAuditConfLog = "ddl"
const PGAuditConfLogFunction PGAuditConfLog = "function"

type PGAuditConfLogLevel string

const PGAuditConfLogLevelDebug1 PGAuditConfLogLevel = "debug1"
const PGAuditConfLogLevelDebug2 PGAuditConfLogLevel = "debug2"
const PGAuditConfLogLevelDebug3 PGAuditConfLogLevel = "debug3"
const PGAuditConfLogLevelDebug4 PGAuditConfLogLevel = "debug4"
const PGAuditConfLogLevelDebug5 PGAuditConfLogLevel = "debug5"
const PGAuditConfLogLevelInfo PGAuditConfLogLevel = "info"
const PGAuditConfLogLevelLog PGAuditConfLogLevel = "log"
const PGAuditConfLogLevelNotice PGAuditConfLogLevel = "notice"
const PGAuditConfLogLevelWarning PGAuditConfLogLevel = "warning"

var enumValues_PGAuditConfLogLevel = []interface{}{
	"debug5",
	"debug4",
	"debug3",
	"debug2",
	"debug1",
	"info",
	"notice",
	"warning",
	"log",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLogLevel) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLogLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLogLevel, v)
	}
	*j = PGAuditConfLogLevel(v)
	return nil
}

const PGAuditConfLogMisc PGAuditConfLog = "misc"
const PGAuditConfLogMiscSet PGAuditConfLog = "misc_set"
const PGAuditConfLogNone PGAuditConfLog = "none"

type PGAuditConfLogParameter string

const PGAuditConfLogParameterOff PGAuditConfLogParameter = "off"
const PGAuditConfLogParameterOn PGAuditConfLogParameter = "on"

var enumValues_PGAuditConfLogParameter = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLogParameter) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLogParameter {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLogParameter, v)
	}
	*j = PGAuditConfLogParameter(v)
	return nil
}

const PGAuditConfLogRead PGAuditConfLog = "read"

type PGAuditConfLogRelation string

const PGAuditConfLogRelationOff PGAuditConfLogRelation = "off"
const PGAuditConfLogRelationOn PGAuditConfLogRelation = "on"

var enumValues_PGAuditConfLogRelation = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLogRelation) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLogRelation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLogRelation, v)
	}
	*j = PGAuditConfLogRelation(v)
	return nil
}

const PGAuditConfLogRole PGAuditConfLog = "role"

type PGAuditConfLogStatement string

const PGAuditConfLogStatementOff PGAuditConfLogStatement = "off"
const PGAuditConfLogStatementOn PGAuditConfLogStatement = "on"

type PGAuditConfLogStatementOnce string

const PGAuditConfLogStatementOnceOff PGAuditConfLogStatementOnce = "off"
const PGAuditConfLogStatementOnceOn PGAuditConfLogStatementOnce = "on"

var enumValues_PGAuditConfLogStatementOnce = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLogStatementOnce) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLogStatementOnce {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLogStatementOnce, v)
	}
	*j = PGAuditConfLogStatementOnce(v)
	return nil
}

var enumValues_PGAuditConfLogStatement = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLogStatement) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLogStatement {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLogStatement, v)
	}
	*j = PGAuditConfLogStatement(v)
	return nil
}

const PGAuditConfLogWrite PGAuditConfLog = "write"

var enumValues_PGAuditConfLog = []interface{}{
	"none",
	"read",
	"write",
	"function",
	"role",
	"ddl",
	"misc",
	"misc_set",
	"all",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLog) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLog {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLog, v)
	}
	*j = PGAuditConfLog(v)
	return nil
}

type PGAuditConfObjectLog string

const PGAuditConfObjectLogAll PGAuditConfObjectLog = "all"

type PGAuditConfObjectLogCatalog string

const PGAuditConfObjectLogCatalogOff PGAuditConfObjectLogCatalog = "off"
const PGAuditConfObjectLogCatalogOn PGAuditConfObjectLogCatalog = "on"

var enumValues_PGAuditConfObjectLogCatalog = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfObjectLogCatalog) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfObjectLogCatalog {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfObjectLogCatalog, v)
	}
	*j = PGAuditConfObjectLogCatalog(v)
	return nil
}

const PGAuditConfObjectLogDdl PGAuditConfObjectLog = "ddl"
const PGAuditConfObjectLogFunction PGAuditConfObjectLog = "function"
const PGAuditConfObjectLogMisc PGAuditConfObjectLog = "misc"
const PGAuditConfObjectLogMiscSet PGAuditConfObjectLog = "misc_set"
const PGAuditConfObjectLogNone PGAuditConfObjectLog = "none"
const PGAuditConfObjectLogRead PGAuditConfObjectLog = "read"
const PGAuditConfObjectLogRole PGAuditConfObjectLog = "role"
const PGAuditConfObjectLogWrite PGAuditConfObjectLog = "write"

var enumValues_PGAuditConfObjectLog = []interface{}{
	"none",
	"read",
	"write",
	"function",
	"role",
	"ddl",
	"misc",
	"misc_set",
	"all",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfObjectLog) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfObjectLog {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfObjectLog, v)
	}
	*j = PGAuditConfObjectLog(v)
	return nil
}

type PGAuditConfSessionLogStatementName string

const PGAuditConfSessionLogStatementNameOff PGAuditConfSessionLogStatementName = "off"
const PGAuditConfSessionLogStatementNameOn PGAuditConfSessionLogStatementName = "on"

var enumValues_PGAuditConfSessionLogStatementName = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfSessionLogStatementName) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfSessionLogStatementName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfSessionLogStatementName, v)
	}
	*j = PGAuditConfSessionLogStatementName(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConf) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain PGAuditConf
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["filter_using_role"]; !ok || v == nil {
		plain.FilterUsingRole = "off"
	}
	if v, ok := raw["log"]; !ok || v == nil {
		plain.Log = "none"
	}
	if v, ok := raw["log_catalog"]; !ok || v == nil {
		plain.LogCatalog = "on"
	}
	if v, ok := raw["log_client"]; !ok || v == nil {
		plain.LogClient = "off"
	}
	if v, ok := raw["log_level"]; !ok || v == nil {
		plain.LogLevel = "log"
	}
	if v, ok := raw["log_parameter"]; !ok || v == nil {
		plain.LogParameter = "off"
	}
	if v, ok := raw["log_parameter_max_size"]; !ok || v == nil {
		plain.LogParameterMaxSize = "0"
	}
	if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, string(plain.LogParameterMaxSize)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "LogParameterMaxSize", `^[0-9]+[kMGT]?B?$`)
	}
	if v, ok := raw["log_relation"]; !ok || v == nil {
		plain.LogRelation = "off"
	}
	if v, ok := raw["log_statement"]; !ok || v == nil {
		plain.LogStatement = "on"
	}
	if v, ok := raw["log_statement_once"]; !ok || v == nil {
		plain.LogStatementOnce = "off"
	}
	if plain.MaxStackDepth != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.MaxStackDepth.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MaxStackDepth", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if v, ok := raw["object_log"]; !ok || v == nil {
		plain.ObjectLog = "none"
	}
	if v, ok := raw["object_log_catalog"]; !ok || v == nil {
		plain.ObjectLogCatalog = "on"
	}
	if v, ok := raw["session_log_statement_name"]; !ok || v == nil {
		plain.SessionLogStatementName = "off"
	}
	*j = PGAuditConf(plain)
	return nil
}

// PgBouncer connection pooler configuration
type PgBouncerConf struct {
	// Administrative password for PgBouncer
	AdminPassword *string `json:"admin_password,omitempty" yaml:"admin_password,omitempty" mapstructure:"admin_password,omitempty"`

	// Administrative user for PgBouncer
	AdminUser *string `json:"admin_user,omitempty" yaml:"admin_user,omitempty" mapstructure:"admin_user,omitempty"`

	// Path to authentication file
	AuthFile string `json:"auth_file,omitempty" yaml:"auth_file,omitempty" mapstructure:"auth_file,omitempty"`

	// Query to authenticate users
	AuthQuery string `json:"auth_query,omitempty" yaml:"auth_query,omitempty" mapstructure:"auth_query,omitempty"`

	// Authentication type for PgBouncer
	AuthType PgBouncerConfAuthType `json:"auth_type,omitempty" yaml:"auth_type,omitempty" mapstructure:"auth_type,omitempty"`

	// Maximum idle time for client connections
	ClientIdleTimeout string `json:"client_idle_timeout,omitempty" yaml:"client_idle_timeout,omitempty" mapstructure:"client_idle_timeout,omitempty"`

	// Database connection configurations
	Databases map[string]DatabaseConfig `json:"databases,omitempty" yaml:"databases,omitempty" mapstructure:"databases,omitempty"`

	// Default pool size for databases
	DefaultPoolSize int `json:"default_pool_size,omitempty" yaml:"default_pool_size,omitempty" mapstructure:"default_pool_size,omitempty"`

	// Specifies the address to listen on
	ListenAddress string `json:"listen_address,omitempty" yaml:"listen_address,omitempty" mapstructure:"listen_address,omitempty"`

	// Specifies the port to listen on
	ListenPort int `json:"listen_port,omitempty" yaml:"listen_port,omitempty" mapstructure:"listen_port,omitempty"`

	// Maximum number of client connections allowed
	MaxClientConn int `json:"max_client_conn,omitempty" yaml:"max_client_conn,omitempty" mapstructure:"max_client_conn,omitempty"`

	// Minimum pool size
	MinPoolSize int `json:"min_pool_size,omitempty" yaml:"min_pool_size,omitempty" mapstructure:"min_pool_size,omitempty"`

	// Pooling mode to use
	PoolMode PgBouncerConfPoolMode `json:"pool_mode,omitempty" yaml:"pool_mode,omitempty" mapstructure:"pool_mode,omitempty"`

	// Query timeout
	QueryTimeout string `json:"query_timeout,omitempty" yaml:"query_timeout,omitempty" mapstructure:"query_timeout,omitempty"`

	// Reserved pool size
	ReservePoolSize *int `json:"reserve_pool_size,omitempty" yaml:"reserve_pool_size,omitempty" mapstructure:"reserve_pool_size,omitempty"`

	// Maximum idle time for server connections
	ServerIdleTimeout string `json:"server_idle_timeout,omitempty" yaml:"server_idle_timeout,omitempty" mapstructure:"server_idle_timeout,omitempty"`

	// Maximum lifetime of a server connection
	ServerLifetime string `json:"server_lifetime,omitempty" yaml:"server_lifetime,omitempty" mapstructure:"server_lifetime,omitempty"`

	// Query to run on server connection before returning to pool
	ServerResetQuery string `json:"server_reset_query,omitempty" yaml:"server_reset_query,omitempty" mapstructure:"server_reset_query,omitempty"`
}

type PgBouncerConfAuthType string

const PgBouncerConfAuthTypeAny PgBouncerConfAuthType = "any"
const PgBouncerConfAuthTypeCert PgBouncerConfAuthType = "cert"
const PgBouncerConfAuthTypeHba PgBouncerConfAuthType = "hba"
const PgBouncerConfAuthTypeMd5 PgBouncerConfAuthType = "md5"
const PgBouncerConfAuthTypePam PgBouncerConfAuthType = "pam"
const PgBouncerConfAuthTypePlain PgBouncerConfAuthType = "plain"
const PgBouncerConfAuthTypeScramSha256 PgBouncerConfAuthType = "scram-sha-256"
const PgBouncerConfAuthTypeTrust PgBouncerConfAuthType = "trust"

var enumValues_PgBouncerConfAuthType = []interface{}{
	"any",
	"trust",
	"plain",
	"md5",
	"scram-sha-256",
	"cert",
	"hba",
	"pam",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PgBouncerConfAuthType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PgBouncerConfAuthType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PgBouncerConfAuthType, v)
	}
	*j = PgBouncerConfAuthType(v)
	return nil
}

type PgBouncerConfPoolMode string

const PgBouncerConfPoolModeSession PgBouncerConfPoolMode = "session"
const PgBouncerConfPoolModeStatement PgBouncerConfPoolMode = "statement"
const PgBouncerConfPoolModeTransaction PgBouncerConfPoolMode = "transaction"

var enumValues_PgBouncerConfPoolMode = []interface{}{
	"session",
	"transaction",
	"statement",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PgBouncerConfPoolMode) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PgBouncerConfPoolMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PgBouncerConfPoolMode, v)
	}
	*j = PgBouncerConfPoolMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PgBouncerConf) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain PgBouncerConf
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["auth_file"]; !ok || v == nil {
		plain.AuthFile = "userlist.txt"
	}
	if v, ok := raw["auth_query"]; !ok || v == nil {
		plain.AuthQuery = "SELECT usename, passwd FROM pg_shadow WHERE usename=$1"
	}
	if v, ok := raw["auth_type"]; !ok || v == nil {
		plain.AuthType = "md5"
	}
	if v, ok := raw["client_idle_timeout"]; !ok || v == nil {
		plain.ClientIdleTimeout = "0"
	}
	if matched, _ := regexp.MatchString(`^[0-9]+(us|ms|s|min|h|d)?$`, string(plain.ClientIdleTimeout)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "ClientIdleTimeout", `^[0-9]+(us|ms|s|min|h|d)?$`)
	}
	if v, ok := raw["default_pool_size"]; !ok || v == nil {
		plain.DefaultPoolSize = 25.0
	}
	if 1 > plain.DefaultPoolSize {
		return fmt.Errorf("field %s: must be >= %v", "default_pool_size", 1)
	}
	if v, ok := raw["listen_address"]; !ok || v == nil {
		plain.ListenAddress = "0.0.0.0"
	}
	if v, ok := raw["listen_port"]; !ok || v == nil {
		plain.ListenPort = 6432.0
	}
	if 65535 < plain.ListenPort {
		return fmt.Errorf("field %s: must be <= %v", "listen_port", 65535)
	}
	if 1 > plain.ListenPort {
		return fmt.Errorf("field %s: must be >= %v", "listen_port", 1)
	}
	if v, ok := raw["max_client_conn"]; !ok || v == nil {
		plain.MaxClientConn = 100.0
	}
	if 1 > plain.MaxClientConn {
		return fmt.Errorf("field %s: must be >= %v", "max_client_conn", 1)
	}
	if v, ok := raw["min_pool_size"]; !ok || v == nil {
		plain.MinPoolSize = 0.0
	}
	if 0 > plain.MinPoolSize {
		return fmt.Errorf("field %s: must be >= %v", "min_pool_size", 0)
	}
	if v, ok := raw["pool_mode"]; !ok || v == nil {
		plain.PoolMode = "transaction"
	}
	if v, ok := raw["query_timeout"]; !ok || v == nil {
		plain.QueryTimeout = "0"
	}
	if matched, _ := regexp.MatchString(`^[0-9]+(us|ms|s|min|h|d)?$`, string(plain.QueryTimeout)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "QueryTimeout", `^[0-9]+(us|ms|s|min|h|d)?$`)
	}
	if plain.ReservePoolSize != nil && 0 > *plain.ReservePoolSize {
		return fmt.Errorf("field %s: must be >= %v", "reserve_pool_size", 0)
	}
	if v, ok := raw["server_idle_timeout"]; !ok || v == nil {
		plain.ServerIdleTimeout = "600s"
	}
	if matched, _ := regexp.MatchString(`^[0-9]+(us|ms|s|min|h|d)?$`, string(plain.ServerIdleTimeout)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "ServerIdleTimeout", `^[0-9]+(us|ms|s|min|h|d)?$`)
	}
	if v, ok := raw["server_lifetime"]; !ok || v == nil {
		plain.ServerLifetime = "3600s"
	}
	if matched, _ := regexp.MatchString(`^[0-9]+(us|ms|s|min|h|d)?$`, string(plain.ServerLifetime)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "ServerLifetime", `^[0-9]+(us|ms|s|min|h|d)?$`)
	}
	if v, ok := raw["server_reset_query"]; !ok || v == nil {
		plain.ServerResetQuery = "DISCARD ALL"
	}
	*j = PgBouncerConf(plain)
	return nil
}

// PostgreSQL host-based authentication configuration
type PgHBAConf struct {
	// List of host-based authentication rules
	Rules []PgHBAConfRulesElem `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`
}

type PgHBAConfRulesElem struct {
	// Client IP address, hostname, or CIDR range
	Address *string `json:"address,omitempty" yaml:"address,omitempty" mapstructure:"address,omitempty"`

	// Database name or 'all'
	Database string `json:"database" yaml:"database" mapstructure:"database"`

	// Authentication method
	Method PgHBAConfRulesElemMethod `json:"method" yaml:"method" mapstructure:"method"`

	// Additional authentication options
	Options map[string]string `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Connection type
	Type PgHBAConfRulesElemType `json:"type" yaml:"type" mapstructure:"type"`

	// Username or 'all'
	User string `json:"user" yaml:"user" mapstructure:"user"`
}

type PgHBAConfRulesElemMethod string

const PgHBAConfRulesElemMethodBsd PgHBAConfRulesElemMethod = "bsd"
const PgHBAConfRulesElemMethodCert PgHBAConfRulesElemMethod = "cert"
const PgHBAConfRulesElemMethodGss PgHBAConfRulesElemMethod = "gss"
const PgHBAConfRulesElemMethodIdent PgHBAConfRulesElemMethod = "ident"
const PgHBAConfRulesElemMethodLdap PgHBAConfRulesElemMethod = "ldap"
const PgHBAConfRulesElemMethodMd5 PgHBAConfRulesElemMethod = "md5"
const PgHBAConfRulesElemMethodPam PgHBAConfRulesElemMethod = "pam"
const PgHBAConfRulesElemMethodPassword PgHBAConfRulesElemMethod = "password"
const PgHBAConfRulesElemMethodPeer PgHBAConfRulesElemMethod = "peer"
const PgHBAConfRulesElemMethodRadius PgHBAConfRulesElemMethod = "radius"
const PgHBAConfRulesElemMethodReject PgHBAConfRulesElemMethod = "reject"
const PgHBAConfRulesElemMethodScramSha256 PgHBAConfRulesElemMethod = "scram-sha-256"
const PgHBAConfRulesElemMethodSspi PgHBAConfRulesElemMethod = "sspi"
const PgHBAConfRulesElemMethodTrust PgHBAConfRulesElemMethod = "trust"

var enumValues_PgHBAConfRulesElemMethod = []interface{}{
	"trust",
	"reject",
	"md5",
	"password",
	"scram-sha-256",
	"gss",
	"sspi",
	"ident",
	"peer",
	"ldap",
	"radius",
	"cert",
	"pam",
	"bsd",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PgHBAConfRulesElemMethod) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PgHBAConfRulesElemMethod {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PgHBAConfRulesElemMethod, v)
	}
	*j = PgHBAConfRulesElemMethod(v)
	return nil
}

type PgHBAConfRulesElemType string

const PgHBAConfRulesElemTypeHost PgHBAConfRulesElemType = "host"
const PgHBAConfRulesElemTypeHostgssenc PgHBAConfRulesElemType = "hostgssenc"
const PgHBAConfRulesElemTypeHostnogssenc PgHBAConfRulesElemType = "hostnogssenc"
const PgHBAConfRulesElemTypeHostnossl PgHBAConfRulesElemType = "hostnossl"
const PgHBAConfRulesElemTypeHostssl PgHBAConfRulesElemType = "hostssl"
const PgHBAConfRulesElemTypeLocal PgHBAConfRulesElemType = "local"

var enumValues_PgHBAConfRulesElemType = []interface{}{
	"local",
	"host",
	"hostssl",
	"hostnossl",
	"hostgssenc",
	"hostnogssenc",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PgHBAConfRulesElemType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PgHBAConfRulesElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PgHBAConfRulesElemType, v)
	}
	*j = PgHBAConfRulesElemType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PgHBAConfRulesElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in PgHBAConfRulesElem: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in PgHBAConfRulesElem: required")
	}
	type Plain PgHBAConfRulesElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["database"]; !ok || v == nil {
		plain.Database = "all"
	}
	if v, ok := raw["user"]; !ok || v == nil {
		plain.User = "all"
	}
	*j = PgHBAConfRulesElem(plain)
	return nil
}

type PgconfigSchemaJson struct {
	// Pgaudit corresponds to the JSON schema field "pgaudit".
	Pgaudit *PGAuditConf `json:"pgaudit,omitempty" yaml:"pgaudit,omitempty" mapstructure:"pgaudit,omitempty"`

	// Pgbouncer corresponds to the JSON schema field "pgbouncer".
	Pgbouncer *PgBouncerConf `json:"pgbouncer,omitempty" yaml:"pgbouncer,omitempty" mapstructure:"pgbouncer,omitempty"`

	// Pghba corresponds to the JSON schema field "pghba".
	Pghba *PgHBAConf `json:"pghba,omitempty" yaml:"pghba,omitempty" mapstructure:"pghba,omitempty"`

	// Postgres corresponds to the JSON schema field "postgres".
	Postgres *PostgresConf `json:"postgres,omitempty" yaml:"postgres,omitempty" mapstructure:"postgres,omitempty"`

	// Postgrest corresponds to the JSON schema field "postgrest".
	Postgrest *PostgrestConf `json:"postgrest,omitempty" yaml:"postgrest,omitempty" mapstructure:"postgrest,omitempty"`

	// Walg corresponds to the JSON schema field "walg".
	Walg *WalgConf `json:"walg,omitempty" yaml:"walg,omitempty" mapstructure:"walg,omitempty"`
}

// Main PostgreSQL server configuration
type PostgresConf struct {
	// \N
	DateStyle *string `json:"DateStyle,omitempty" yaml:"DateStyle,omitempty" mapstructure:"DateStyle,omitempty"`

	// \N
	IntervalStyle string `json:"IntervalStyle,omitempty" yaml:"IntervalStyle,omitempty" mapstructure:"IntervalStyle,omitempty"`

	// \N
	TimeZone *string `json:"TimeZone,omitempty" yaml:"TimeZone,omitempty" mapstructure:"TimeZone,omitempty"`

	// \N
	AllowAlterSystem *bool `json:"allow_alter_system,omitempty" yaml:"allow_alter_system,omitempty" mapstructure:"allow_alter_system,omitempty"`

	// \N
	AllowInPlaceTablespaces *bool `json:"allow_in_place_tablespaces,omitempty" yaml:"allow_in_place_tablespaces,omitempty" mapstructure:"allow_in_place_tablespaces,omitempty"`

	// \N
	AllowSystemTableMods *bool `json:"allow_system_table_mods,omitempty" yaml:"allow_system_table_mods,omitempty" mapstructure:"allow_system_table_mods,omitempty"`

	// \N
	ApplicationName *string `json:"application_name,omitempty" yaml:"application_name,omitempty" mapstructure:"application_name,omitempty"`

	// \N
	ArchiveCleanupCommand *string `json:"archive_cleanup_command,omitempty" yaml:"archive_cleanup_command,omitempty" mapstructure:"archive_cleanup_command,omitempty"`

	// \N
	ArchiveCommand *string `json:"archive_command,omitempty" yaml:"archive_command,omitempty" mapstructure:"archive_command,omitempty"`

	// \N
	ArchiveLibrary *string `json:"archive_library,omitempty" yaml:"archive_library,omitempty" mapstructure:"archive_library,omitempty"`

	// \N
	ArchiveMode string `json:"archive_mode,omitempty" yaml:"archive_mode,omitempty" mapstructure:"archive_mode,omitempty"`

	// \N
	ArchiveTimeout *types.Duration `json:"archive_timeout,omitempty" yaml:"archive_timeout,omitempty" mapstructure:"archive_timeout,omitempty"`

	// \N
	ArrayNulls *bool `json:"array_nulls,omitempty" yaml:"array_nulls,omitempty" mapstructure:"array_nulls,omitempty"`

	// \N
	AuthenticationTimeout *types.Duration `json:"authentication_timeout,omitempty" yaml:"authentication_timeout,omitempty" mapstructure:"authentication_timeout,omitempty"`

	// \N
	Autovacuum *bool `json:"autovacuum,omitempty" yaml:"autovacuum,omitempty" mapstructure:"autovacuum,omitempty"`

	// \N
	AutovacuumAnalyzeScaleFactor *float64 `json:"autovacuum_analyze_scale_factor,omitempty" yaml:"autovacuum_analyze_scale_factor,omitempty" mapstructure:"autovacuum_analyze_scale_factor,omitempty"`

	// \N
	AutovacuumAnalyzeThreshold *int `json:"autovacuum_analyze_threshold,omitempty" yaml:"autovacuum_analyze_threshold,omitempty" mapstructure:"autovacuum_analyze_threshold,omitempty"`

	// \N
	AutovacuumFreezeMaxAge *int `json:"autovacuum_freeze_max_age,omitempty" yaml:"autovacuum_freeze_max_age,omitempty" mapstructure:"autovacuum_freeze_max_age,omitempty"`

	// \N
	AutovacuumMaxWorkers *int `json:"autovacuum_max_workers,omitempty" yaml:"autovacuum_max_workers,omitempty" mapstructure:"autovacuum_max_workers,omitempty"`

	// \N
	AutovacuumMultixactFreezeMaxAge *int `json:"autovacuum_multixact_freeze_max_age,omitempty" yaml:"autovacuum_multixact_freeze_max_age,omitempty" mapstructure:"autovacuum_multixact_freeze_max_age,omitempty"`

	// \N
	AutovacuumNaptime *types.Duration `json:"autovacuum_naptime,omitempty" yaml:"autovacuum_naptime,omitempty" mapstructure:"autovacuum_naptime,omitempty"`

	// \N
	AutovacuumVacuumCostDelay *types.Duration `json:"autovacuum_vacuum_cost_delay,omitempty" yaml:"autovacuum_vacuum_cost_delay,omitempty" mapstructure:"autovacuum_vacuum_cost_delay,omitempty"`

	// \N
	AutovacuumVacuumCostLimit *int `json:"autovacuum_vacuum_cost_limit,omitempty" yaml:"autovacuum_vacuum_cost_limit,omitempty" mapstructure:"autovacuum_vacuum_cost_limit,omitempty"`

	// \N
	AutovacuumVacuumInsertScaleFactor *float64 `json:"autovacuum_vacuum_insert_scale_factor,omitempty" yaml:"autovacuum_vacuum_insert_scale_factor,omitempty" mapstructure:"autovacuum_vacuum_insert_scale_factor,omitempty"`

	// \N
	AutovacuumVacuumInsertThreshold *int `json:"autovacuum_vacuum_insert_threshold,omitempty" yaml:"autovacuum_vacuum_insert_threshold,omitempty" mapstructure:"autovacuum_vacuum_insert_threshold,omitempty"`

	// \N
	AutovacuumVacuumScaleFactor *float64 `json:"autovacuum_vacuum_scale_factor,omitempty" yaml:"autovacuum_vacuum_scale_factor,omitempty" mapstructure:"autovacuum_vacuum_scale_factor,omitempty"`

	// \N
	AutovacuumVacuumThreshold *int `json:"autovacuum_vacuum_threshold,omitempty" yaml:"autovacuum_vacuum_threshold,omitempty" mapstructure:"autovacuum_vacuum_threshold,omitempty"`

	// \N
	AutovacuumWorkMem *types.Size `json:"autovacuum_work_mem,omitempty" yaml:"autovacuum_work_mem,omitempty" mapstructure:"autovacuum_work_mem,omitempty"`

	// \N
	BackendFlushAfter *types.Size `json:"backend_flush_after,omitempty" yaml:"backend_flush_after,omitempty" mapstructure:"backend_flush_after,omitempty"`

	// \N
	BackslashQuote string `json:"backslash_quote,omitempty" yaml:"backslash_quote,omitempty" mapstructure:"backslash_quote,omitempty"`

	// \N
	BacktraceFunctions *string `json:"backtrace_functions,omitempty" yaml:"backtrace_functions,omitempty" mapstructure:"backtrace_functions,omitempty"`

	// \N
	BgwriterDelay *types.Duration `json:"bgwriter_delay,omitempty" yaml:"bgwriter_delay,omitempty" mapstructure:"bgwriter_delay,omitempty"`

	// \N
	BgwriterFlushAfter *types.Size `json:"bgwriter_flush_after,omitempty" yaml:"bgwriter_flush_after,omitempty" mapstructure:"bgwriter_flush_after,omitempty"`

	// \N
	BgwriterLruMaxpages *int `json:"bgwriter_lru_maxpages,omitempty" yaml:"bgwriter_lru_maxpages,omitempty" mapstructure:"bgwriter_lru_maxpages,omitempty"`

	// \N
	BgwriterLruMultiplier *float64 `json:"bgwriter_lru_multiplier,omitempty" yaml:"bgwriter_lru_multiplier,omitempty" mapstructure:"bgwriter_lru_multiplier,omitempty"`

	// \N
	Bonjour *bool `json:"bonjour,omitempty" yaml:"bonjour,omitempty" mapstructure:"bonjour,omitempty"`

	// \N
	BonjourName *string `json:"bonjour_name,omitempty" yaml:"bonjour_name,omitempty" mapstructure:"bonjour_name,omitempty"`

	// \N
	ByteaOutput string `json:"bytea_output,omitempty" yaml:"bytea_output,omitempty" mapstructure:"bytea_output,omitempty"`

	// \N
	CheckFunctionBodies *bool `json:"check_function_bodies,omitempty" yaml:"check_function_bodies,omitempty" mapstructure:"check_function_bodies,omitempty"`

	// \N
	CheckpointCompletionTarget *float64 `json:"checkpoint_completion_target,omitempty" yaml:"checkpoint_completion_target,omitempty" mapstructure:"checkpoint_completion_target,omitempty"`

	// \N
	CheckpointFlushAfter *types.Size `json:"checkpoint_flush_after,omitempty" yaml:"checkpoint_flush_after,omitempty" mapstructure:"checkpoint_flush_after,omitempty"`

	// \N
	CheckpointTimeout *types.Duration `json:"checkpoint_timeout,omitempty" yaml:"checkpoint_timeout,omitempty" mapstructure:"checkpoint_timeout,omitempty"`

	// \N
	CheckpointWarning *types.Duration `json:"checkpoint_warning,omitempty" yaml:"checkpoint_warning,omitempty" mapstructure:"checkpoint_warning,omitempty"`

	// \N
	ClientConnectionCheckInterval *types.Duration `json:"client_connection_check_interval,omitempty" yaml:"client_connection_check_interval,omitempty" mapstructure:"client_connection_check_interval,omitempty"`

	// \N
	ClientEncoding *string `json:"client_encoding,omitempty" yaml:"client_encoding,omitempty" mapstructure:"client_encoding,omitempty"`

	// \N
	ClientMinMessages string `json:"client_min_messages,omitempty" yaml:"client_min_messages,omitempty" mapstructure:"client_min_messages,omitempty"`

	// \N
	ClusterName *string `json:"cluster_name,omitempty" yaml:"cluster_name,omitempty" mapstructure:"cluster_name,omitempty"`

	// \N
	CommitDelay *int `json:"commit_delay,omitempty" yaml:"commit_delay,omitempty" mapstructure:"commit_delay,omitempty"`

	// \N
	CommitSiblings *int `json:"commit_siblings,omitempty" yaml:"commit_siblings,omitempty" mapstructure:"commit_siblings,omitempty"`

	// \N
	CommitTimestampBuffers *types.Size `json:"commit_timestamp_buffers,omitempty" yaml:"commit_timestamp_buffers,omitempty" mapstructure:"commit_timestamp_buffers,omitempty"`

	// \N
	ComputeQueryId string `json:"compute_query_id,omitempty" yaml:"compute_query_id,omitempty" mapstructure:"compute_query_id,omitempty"`

	// \N
	ConfigFile *string `json:"config_file,omitempty" yaml:"config_file,omitempty" mapstructure:"config_file,omitempty"`

	// \N
	ConstraintExclusion string `json:"constraint_exclusion,omitempty" yaml:"constraint_exclusion,omitempty" mapstructure:"constraint_exclusion,omitempty"`

	// \N
	CpuIndexTupleCost *float64 `json:"cpu_index_tuple_cost,omitempty" yaml:"cpu_index_tuple_cost,omitempty" mapstructure:"cpu_index_tuple_cost,omitempty"`

	// \N
	CpuOperatorCost *float64 `json:"cpu_operator_cost,omitempty" yaml:"cpu_operator_cost,omitempty" mapstructure:"cpu_operator_cost,omitempty"`

	// \N
	CpuTupleCost *float64 `json:"cpu_tuple_cost,omitempty" yaml:"cpu_tuple_cost,omitempty" mapstructure:"cpu_tuple_cost,omitempty"`

	// \N
	CreateroleSelfGrant *string `json:"createrole_self_grant,omitempty" yaml:"createrole_self_grant,omitempty" mapstructure:"createrole_self_grant,omitempty"`

	// \N
	CursorTupleFraction *float64 `json:"cursor_tuple_fraction,omitempty" yaml:"cursor_tuple_fraction,omitempty" mapstructure:"cursor_tuple_fraction,omitempty"`

	// \N
	DataDirectory *string `json:"data_directory,omitempty" yaml:"data_directory,omitempty" mapstructure:"data_directory,omitempty"`

	// \N
	DataSyncRetry *bool `json:"data_sync_retry,omitempty" yaml:"data_sync_retry,omitempty" mapstructure:"data_sync_retry,omitempty"`

	// \N
	DeadlockTimeout *types.Duration `json:"deadlock_timeout,omitempty" yaml:"deadlock_timeout,omitempty" mapstructure:"deadlock_timeout,omitempty"`

	// \N
	DebugDiscardCaches *int `json:"debug_discard_caches,omitempty" yaml:"debug_discard_caches,omitempty" mapstructure:"debug_discard_caches,omitempty"`

	// \N
	DebugIoDirect *string `json:"debug_io_direct,omitempty" yaml:"debug_io_direct,omitempty" mapstructure:"debug_io_direct,omitempty"`

	// \N
	DebugLogicalReplicationStreaming string `json:"debug_logical_replication_streaming,omitempty" yaml:"debug_logical_replication_streaming,omitempty" mapstructure:"debug_logical_replication_streaming,omitempty"`

	// \N
	DebugParallelQuery string `json:"debug_parallel_query,omitempty" yaml:"debug_parallel_query,omitempty" mapstructure:"debug_parallel_query,omitempty"`

	// \N
	DebugPrettyPrint *bool `json:"debug_pretty_print,omitempty" yaml:"debug_pretty_print,omitempty" mapstructure:"debug_pretty_print,omitempty"`

	// \N
	DebugPrintParse *bool `json:"debug_print_parse,omitempty" yaml:"debug_print_parse,omitempty" mapstructure:"debug_print_parse,omitempty"`

	// \N
	DebugPrintPlan *bool `json:"debug_print_plan,omitempty" yaml:"debug_print_plan,omitempty" mapstructure:"debug_print_plan,omitempty"`

	// \N
	DebugPrintRewritten *bool `json:"debug_print_rewritten,omitempty" yaml:"debug_print_rewritten,omitempty" mapstructure:"debug_print_rewritten,omitempty"`

	// \N
	DefaultStatisticsTarget *int `json:"default_statistics_target,omitempty" yaml:"default_statistics_target,omitempty" mapstructure:"default_statistics_target,omitempty"`

	// \N
	DefaultTableAccessMethod *string `json:"default_table_access_method,omitempty" yaml:"default_table_access_method,omitempty" mapstructure:"default_table_access_method,omitempty"`

	// \N
	DefaultTablespace *string `json:"default_tablespace,omitempty" yaml:"default_tablespace,omitempty" mapstructure:"default_tablespace,omitempty"`

	// \N
	DefaultTextSearchConfig *string `json:"default_text_search_config,omitempty" yaml:"default_text_search_config,omitempty" mapstructure:"default_text_search_config,omitempty"`

	// \N
	DefaultToastCompression string `json:"default_toast_compression,omitempty" yaml:"default_toast_compression,omitempty" mapstructure:"default_toast_compression,omitempty"`

	// \N
	DefaultTransactionDeferrable *bool `json:"default_transaction_deferrable,omitempty" yaml:"default_transaction_deferrable,omitempty" mapstructure:"default_transaction_deferrable,omitempty"`

	// \N
	DefaultTransactionIsolation string `json:"default_transaction_isolation,omitempty" yaml:"default_transaction_isolation,omitempty" mapstructure:"default_transaction_isolation,omitempty"`

	// \N
	DefaultTransactionReadOnly *bool `json:"default_transaction_read_only,omitempty" yaml:"default_transaction_read_only,omitempty" mapstructure:"default_transaction_read_only,omitempty"`

	// \N
	DynamicLibraryPath *string `json:"dynamic_library_path,omitempty" yaml:"dynamic_library_path,omitempty" mapstructure:"dynamic_library_path,omitempty"`

	// \N
	DynamicSharedMemoryType string `json:"dynamic_shared_memory_type,omitempty" yaml:"dynamic_shared_memory_type,omitempty" mapstructure:"dynamic_shared_memory_type,omitempty"`

	// \N
	EffectiveCacheSize *types.Size `json:"effective_cache_size,omitempty" yaml:"effective_cache_size,omitempty" mapstructure:"effective_cache_size,omitempty"`

	// \N
	EffectiveIoConcurrency *int `json:"effective_io_concurrency,omitempty" yaml:"effective_io_concurrency,omitempty" mapstructure:"effective_io_concurrency,omitempty"`

	// \N
	EnableAsyncAppend *bool `json:"enable_async_append,omitempty" yaml:"enable_async_append,omitempty" mapstructure:"enable_async_append,omitempty"`

	// \N
	EnableBitmapscan *bool `json:"enable_bitmapscan,omitempty" yaml:"enable_bitmapscan,omitempty" mapstructure:"enable_bitmapscan,omitempty"`

	// \N
	EnableGathermerge *bool `json:"enable_gathermerge,omitempty" yaml:"enable_gathermerge,omitempty" mapstructure:"enable_gathermerge,omitempty"`

	// \N
	EnableGroupByReordering *bool `json:"enable_group_by_reordering,omitempty" yaml:"enable_group_by_reordering,omitempty" mapstructure:"enable_group_by_reordering,omitempty"`

	// \N
	EnableHashagg *bool `json:"enable_hashagg,omitempty" yaml:"enable_hashagg,omitempty" mapstructure:"enable_hashagg,omitempty"`

	// \N
	EnableHashjoin *bool `json:"enable_hashjoin,omitempty" yaml:"enable_hashjoin,omitempty" mapstructure:"enable_hashjoin,omitempty"`

	// \N
	EnableIncrementalSort *bool `json:"enable_incremental_sort,omitempty" yaml:"enable_incremental_sort,omitempty" mapstructure:"enable_incremental_sort,omitempty"`

	// \N
	EnableIndexonlyscan *bool `json:"enable_indexonlyscan,omitempty" yaml:"enable_indexonlyscan,omitempty" mapstructure:"enable_indexonlyscan,omitempty"`

	// \N
	EnableIndexscan *bool `json:"enable_indexscan,omitempty" yaml:"enable_indexscan,omitempty" mapstructure:"enable_indexscan,omitempty"`

	// \N
	EnableMaterial *bool `json:"enable_material,omitempty" yaml:"enable_material,omitempty" mapstructure:"enable_material,omitempty"`

	// \N
	EnableMemoize *bool `json:"enable_memoize,omitempty" yaml:"enable_memoize,omitempty" mapstructure:"enable_memoize,omitempty"`

	// \N
	EnableMergejoin *bool `json:"enable_mergejoin,omitempty" yaml:"enable_mergejoin,omitempty" mapstructure:"enable_mergejoin,omitempty"`

	// \N
	EnableNestloop *bool `json:"enable_nestloop,omitempty" yaml:"enable_nestloop,omitempty" mapstructure:"enable_nestloop,omitempty"`

	// \N
	EnableParallelAppend *bool `json:"enable_parallel_append,omitempty" yaml:"enable_parallel_append,omitempty" mapstructure:"enable_parallel_append,omitempty"`

	// \N
	EnableParallelHash *bool `json:"enable_parallel_hash,omitempty" yaml:"enable_parallel_hash,omitempty" mapstructure:"enable_parallel_hash,omitempty"`

	// \N
	EnablePartitionPruning *bool `json:"enable_partition_pruning,omitempty" yaml:"enable_partition_pruning,omitempty" mapstructure:"enable_partition_pruning,omitempty"`

	// \N
	EnablePartitionwiseAggregate *bool `json:"enable_partitionwise_aggregate,omitempty" yaml:"enable_partitionwise_aggregate,omitempty" mapstructure:"enable_partitionwise_aggregate,omitempty"`

	// \N
	EnablePartitionwiseJoin *bool `json:"enable_partitionwise_join,omitempty" yaml:"enable_partitionwise_join,omitempty" mapstructure:"enable_partitionwise_join,omitempty"`

	// \N
	EnablePresortedAggregate *bool `json:"enable_presorted_aggregate,omitempty" yaml:"enable_presorted_aggregate,omitempty" mapstructure:"enable_presorted_aggregate,omitempty"`

	// \N
	EnableSeqscan *bool `json:"enable_seqscan,omitempty" yaml:"enable_seqscan,omitempty" mapstructure:"enable_seqscan,omitempty"`

	// \N
	EnableSort *bool `json:"enable_sort,omitempty" yaml:"enable_sort,omitempty" mapstructure:"enable_sort,omitempty"`

	// \N
	EnableTidscan *bool `json:"enable_tidscan,omitempty" yaml:"enable_tidscan,omitempty" mapstructure:"enable_tidscan,omitempty"`

	// \N
	EscapeStringWarning *bool `json:"escape_string_warning,omitempty" yaml:"escape_string_warning,omitempty" mapstructure:"escape_string_warning,omitempty"`

	// \N
	EventSource *string `json:"event_source,omitempty" yaml:"event_source,omitempty" mapstructure:"event_source,omitempty"`

	// \N
	EventTriggers *bool `json:"event_triggers,omitempty" yaml:"event_triggers,omitempty" mapstructure:"event_triggers,omitempty"`

	// \N
	ExitOnError *bool `json:"exit_on_error,omitempty" yaml:"exit_on_error,omitempty" mapstructure:"exit_on_error,omitempty"`

	// \N
	ExternalPidFile *string `json:"external_pid_file,omitempty" yaml:"external_pid_file,omitempty" mapstructure:"external_pid_file,omitempty"`

	// \N
	ExtraFloatDigits *int `json:"extra_float_digits,omitempty" yaml:"extra_float_digits,omitempty" mapstructure:"extra_float_digits,omitempty"`

	// \N
	FromCollapseLimit *int `json:"from_collapse_limit,omitempty" yaml:"from_collapse_limit,omitempty" mapstructure:"from_collapse_limit,omitempty"`

	// \N
	Fsync *bool `json:"fsync,omitempty" yaml:"fsync,omitempty" mapstructure:"fsync,omitempty"`

	// \N
	FullPageWrites *bool `json:"full_page_writes,omitempty" yaml:"full_page_writes,omitempty" mapstructure:"full_page_writes,omitempty"`

	// \N
	Geqo *bool `json:"geqo,omitempty" yaml:"geqo,omitempty" mapstructure:"geqo,omitempty"`

	// \N
	GeqoEffort *int `json:"geqo_effort,omitempty" yaml:"geqo_effort,omitempty" mapstructure:"geqo_effort,omitempty"`

	// \N
	GeqoGenerations *int `json:"geqo_generations,omitempty" yaml:"geqo_generations,omitempty" mapstructure:"geqo_generations,omitempty"`

	// \N
	GeqoPoolSize *int `json:"geqo_pool_size,omitempty" yaml:"geqo_pool_size,omitempty" mapstructure:"geqo_pool_size,omitempty"`

	// \N
	GeqoSeed *float64 `json:"geqo_seed,omitempty" yaml:"geqo_seed,omitempty" mapstructure:"geqo_seed,omitempty"`

	// \N
	GeqoSelectionBias *float64 `json:"geqo_selection_bias,omitempty" yaml:"geqo_selection_bias,omitempty" mapstructure:"geqo_selection_bias,omitempty"`

	// \N
	GeqoThreshold *int `json:"geqo_threshold,omitempty" yaml:"geqo_threshold,omitempty" mapstructure:"geqo_threshold,omitempty"`

	// \N
	GinFuzzySearchLimit *int `json:"gin_fuzzy_search_limit,omitempty" yaml:"gin_fuzzy_search_limit,omitempty" mapstructure:"gin_fuzzy_search_limit,omitempty"`

	// \N
	GinPendingListLimit *types.Size `json:"gin_pending_list_limit,omitempty" yaml:"gin_pending_list_limit,omitempty" mapstructure:"gin_pending_list_limit,omitempty"`

	// \N
	GssAcceptDelegation *bool `json:"gss_accept_delegation,omitempty" yaml:"gss_accept_delegation,omitempty" mapstructure:"gss_accept_delegation,omitempty"`

	// \N
	HashMemMultiplier *float64 `json:"hash_mem_multiplier,omitempty" yaml:"hash_mem_multiplier,omitempty" mapstructure:"hash_mem_multiplier,omitempty"`

	// \N
	HbaFile *string `json:"hba_file,omitempty" yaml:"hba_file,omitempty" mapstructure:"hba_file,omitempty"`

	// \N
	HotStandby *bool `json:"hot_standby,omitempty" yaml:"hot_standby,omitempty" mapstructure:"hot_standby,omitempty"`

	// \N
	HotStandbyFeedback *bool `json:"hot_standby_feedback,omitempty" yaml:"hot_standby_feedback,omitempty" mapstructure:"hot_standby_feedback,omitempty"`

	// \N
	HugePageSize *types.Size `json:"huge_page_size,omitempty" yaml:"huge_page_size,omitempty" mapstructure:"huge_page_size,omitempty"`

	// \N
	HugePages string `json:"huge_pages,omitempty" yaml:"huge_pages,omitempty" mapstructure:"huge_pages,omitempty"`

	// \N
	IcuValidationLevel string `json:"icu_validation_level,omitempty" yaml:"icu_validation_level,omitempty" mapstructure:"icu_validation_level,omitempty"`

	// \N
	IdentFile *string `json:"ident_file,omitempty" yaml:"ident_file,omitempty" mapstructure:"ident_file,omitempty"`

	// \N
	IdleInTransactionSessionTimeout *types.Duration `json:"idle_in_transaction_session_timeout,omitempty" yaml:"idle_in_transaction_session_timeout,omitempty" mapstructure:"idle_in_transaction_session_timeout,omitempty"`

	// \N
	IdleSessionTimeout *types.Duration `json:"idle_session_timeout,omitempty" yaml:"idle_session_timeout,omitempty" mapstructure:"idle_session_timeout,omitempty"`

	// \N
	IgnoreChecksumFailure *bool `json:"ignore_checksum_failure,omitempty" yaml:"ignore_checksum_failure,omitempty" mapstructure:"ignore_checksum_failure,omitempty"`

	// \N
	IgnoreInvalidPages *bool `json:"ignore_invalid_pages,omitempty" yaml:"ignore_invalid_pages,omitempty" mapstructure:"ignore_invalid_pages,omitempty"`

	// \N
	IgnoreSystemIndexes *bool `json:"ignore_system_indexes,omitempty" yaml:"ignore_system_indexes,omitempty" mapstructure:"ignore_system_indexes,omitempty"`

	// \N
	IoCombineLimit *types.Size `json:"io_combine_limit,omitempty" yaml:"io_combine_limit,omitempty" mapstructure:"io_combine_limit,omitempty"`

	// \N
	Jit *bool `json:"jit,omitempty" yaml:"jit,omitempty" mapstructure:"jit,omitempty"`

	// \N
	JitAboveCost *float64 `json:"jit_above_cost,omitempty" yaml:"jit_above_cost,omitempty" mapstructure:"jit_above_cost,omitempty"`

	// \N
	JitDebuggingSupport *bool `json:"jit_debugging_support,omitempty" yaml:"jit_debugging_support,omitempty" mapstructure:"jit_debugging_support,omitempty"`

	// \N
	JitDumpBitcode *bool `json:"jit_dump_bitcode,omitempty" yaml:"jit_dump_bitcode,omitempty" mapstructure:"jit_dump_bitcode,omitempty"`

	// \N
	JitExpressions *bool `json:"jit_expressions,omitempty" yaml:"jit_expressions,omitempty" mapstructure:"jit_expressions,omitempty"`

	// \N
	JitInlineAboveCost *float64 `json:"jit_inline_above_cost,omitempty" yaml:"jit_inline_above_cost,omitempty" mapstructure:"jit_inline_above_cost,omitempty"`

	// \N
	JitOptimizeAboveCost *float64 `json:"jit_optimize_above_cost,omitempty" yaml:"jit_optimize_above_cost,omitempty" mapstructure:"jit_optimize_above_cost,omitempty"`

	// \N
	JitProfilingSupport *bool `json:"jit_profiling_support,omitempty" yaml:"jit_profiling_support,omitempty" mapstructure:"jit_profiling_support,omitempty"`

	// \N
	JitProvider *string `json:"jit_provider,omitempty" yaml:"jit_provider,omitempty" mapstructure:"jit_provider,omitempty"`

	// \N
	JitTupleDeforming *bool `json:"jit_tuple_deforming,omitempty" yaml:"jit_tuple_deforming,omitempty" mapstructure:"jit_tuple_deforming,omitempty"`

	// \N
	JoinCollapseLimit *int `json:"join_collapse_limit,omitempty" yaml:"join_collapse_limit,omitempty" mapstructure:"join_collapse_limit,omitempty"`

	// \N
	KrbCaseinsUsers *bool `json:"krb_caseins_users,omitempty" yaml:"krb_caseins_users,omitempty" mapstructure:"krb_caseins_users,omitempty"`

	// \N
	KrbServerKeyfile *string `json:"krb_server_keyfile,omitempty" yaml:"krb_server_keyfile,omitempty" mapstructure:"krb_server_keyfile,omitempty"`

	// \N
	LcMessages *string `json:"lc_messages,omitempty" yaml:"lc_messages,omitempty" mapstructure:"lc_messages,omitempty"`

	// \N
	LcMonetary *string `json:"lc_monetary,omitempty" yaml:"lc_monetary,omitempty" mapstructure:"lc_monetary,omitempty"`

	// \N
	LcNumeric *string `json:"lc_numeric,omitempty" yaml:"lc_numeric,omitempty" mapstructure:"lc_numeric,omitempty"`

	// \N
	LcTime *string `json:"lc_time,omitempty" yaml:"lc_time,omitempty" mapstructure:"lc_time,omitempty"`

	// \N
	ListenAddresses *string `json:"listen_addresses,omitempty" yaml:"listen_addresses,omitempty" mapstructure:"listen_addresses,omitempty"`

	// \N
	LoCompatPrivileges *bool `json:"lo_compat_privileges,omitempty" yaml:"lo_compat_privileges,omitempty" mapstructure:"lo_compat_privileges,omitempty"`

	// \N
	LocalPreloadLibraries *string `json:"local_preload_libraries,omitempty" yaml:"local_preload_libraries,omitempty" mapstructure:"local_preload_libraries,omitempty"`

	// \N
	LockTimeout *types.Duration `json:"lock_timeout,omitempty" yaml:"lock_timeout,omitempty" mapstructure:"lock_timeout,omitempty"`

	// \N
	LogAutovacuumMinDuration *types.Duration `json:"log_autovacuum_min_duration,omitempty" yaml:"log_autovacuum_min_duration,omitempty" mapstructure:"log_autovacuum_min_duration,omitempty"`

	// \N
	LogCheckpoints *bool `json:"log_checkpoints,omitempty" yaml:"log_checkpoints,omitempty" mapstructure:"log_checkpoints,omitempty"`

	// \N
	LogConnections *bool `json:"log_connections,omitempty" yaml:"log_connections,omitempty" mapstructure:"log_connections,omitempty"`

	// \N
	LogDestination *string `json:"log_destination,omitempty" yaml:"log_destination,omitempty" mapstructure:"log_destination,omitempty"`

	// \N
	LogDirectory *string `json:"log_directory,omitempty" yaml:"log_directory,omitempty" mapstructure:"log_directory,omitempty"`

	// \N
	LogDisconnections *bool `json:"log_disconnections,omitempty" yaml:"log_disconnections,omitempty" mapstructure:"log_disconnections,omitempty"`

	// \N
	LogDuration *bool `json:"log_duration,omitempty" yaml:"log_duration,omitempty" mapstructure:"log_duration,omitempty"`

	// \N
	LogErrorVerbosity string `json:"log_error_verbosity,omitempty" yaml:"log_error_verbosity,omitempty" mapstructure:"log_error_verbosity,omitempty"`

	// \N
	LogExecutorStats *bool `json:"log_executor_stats,omitempty" yaml:"log_executor_stats,omitempty" mapstructure:"log_executor_stats,omitempty"`

	// \N
	LogFileMode *int `json:"log_file_mode,omitempty" yaml:"log_file_mode,omitempty" mapstructure:"log_file_mode,omitempty"`

	// \N
	LogFilename *string `json:"log_filename,omitempty" yaml:"log_filename,omitempty" mapstructure:"log_filename,omitempty"`

	// \N
	LogHostname *bool `json:"log_hostname,omitempty" yaml:"log_hostname,omitempty" mapstructure:"log_hostname,omitempty"`

	// \N
	LogLinePrefix *string `json:"log_line_prefix,omitempty" yaml:"log_line_prefix,omitempty" mapstructure:"log_line_prefix,omitempty"`

	// \N
	LogLockWaits *bool `json:"log_lock_waits,omitempty" yaml:"log_lock_waits,omitempty" mapstructure:"log_lock_waits,omitempty"`

	// \N
	LogMinDurationSample *types.Duration `json:"log_min_duration_sample,omitempty" yaml:"log_min_duration_sample,omitempty" mapstructure:"log_min_duration_sample,omitempty"`

	// \N
	LogMinDurationStatement *types.Duration `json:"log_min_duration_statement,omitempty" yaml:"log_min_duration_statement,omitempty" mapstructure:"log_min_duration_statement,omitempty"`

	// \N
	LogMinErrorStatement string `json:"log_min_error_statement,omitempty" yaml:"log_min_error_statement,omitempty" mapstructure:"log_min_error_statement,omitempty"`

	// \N
	LogMinMessages string `json:"log_min_messages,omitempty" yaml:"log_min_messages,omitempty" mapstructure:"log_min_messages,omitempty"`

	// \N
	LogParameterMaxLength *int `json:"log_parameter_max_length,omitempty" yaml:"log_parameter_max_length,omitempty" mapstructure:"log_parameter_max_length,omitempty"`

	// \N
	LogParameterMaxLengthOnError *int `json:"log_parameter_max_length_on_error,omitempty" yaml:"log_parameter_max_length_on_error,omitempty" mapstructure:"log_parameter_max_length_on_error,omitempty"`

	// \N
	LogParserStats *bool `json:"log_parser_stats,omitempty" yaml:"log_parser_stats,omitempty" mapstructure:"log_parser_stats,omitempty"`

	// \N
	LogPlannerStats *bool `json:"log_planner_stats,omitempty" yaml:"log_planner_stats,omitempty" mapstructure:"log_planner_stats,omitempty"`

	// \N
	LogRecoveryConflictWaits *bool `json:"log_recovery_conflict_waits,omitempty" yaml:"log_recovery_conflict_waits,omitempty" mapstructure:"log_recovery_conflict_waits,omitempty"`

	// \N
	LogReplicationCommands *bool `json:"log_replication_commands,omitempty" yaml:"log_replication_commands,omitempty" mapstructure:"log_replication_commands,omitempty"`

	// \N
	LogRotationAge *types.Duration `json:"log_rotation_age,omitempty" yaml:"log_rotation_age,omitempty" mapstructure:"log_rotation_age,omitempty"`

	// \N
	LogRotationSize *types.Size `json:"log_rotation_size,omitempty" yaml:"log_rotation_size,omitempty" mapstructure:"log_rotation_size,omitempty"`

	// \N
	LogStartupProgressInterval *types.Duration `json:"log_startup_progress_interval,omitempty" yaml:"log_startup_progress_interval,omitempty" mapstructure:"log_startup_progress_interval,omitempty"`

	// \N
	LogStatement string `json:"log_statement,omitempty" yaml:"log_statement,omitempty" mapstructure:"log_statement,omitempty"`

	// \N
	LogStatementSampleRate *float64 `json:"log_statement_sample_rate,omitempty" yaml:"log_statement_sample_rate,omitempty" mapstructure:"log_statement_sample_rate,omitempty"`

	// \N
	LogStatementStats *bool `json:"log_statement_stats,omitempty" yaml:"log_statement_stats,omitempty" mapstructure:"log_statement_stats,omitempty"`

	// \N
	LogTempFiles *types.Size `json:"log_temp_files,omitempty" yaml:"log_temp_files,omitempty" mapstructure:"log_temp_files,omitempty"`

	// \N
	LogTimezone *string `json:"log_timezone,omitempty" yaml:"log_timezone,omitempty" mapstructure:"log_timezone,omitempty"`

	// \N
	LogTransactionSampleRate *float64 `json:"log_transaction_sample_rate,omitempty" yaml:"log_transaction_sample_rate,omitempty" mapstructure:"log_transaction_sample_rate,omitempty"`

	// \N
	LogTruncateOnRotation *bool `json:"log_truncate_on_rotation,omitempty" yaml:"log_truncate_on_rotation,omitempty" mapstructure:"log_truncate_on_rotation,omitempty"`

	// \N
	LoggingCollector *bool `json:"logging_collector,omitempty" yaml:"logging_collector,omitempty" mapstructure:"logging_collector,omitempty"`

	// \N
	LogicalDecodingWorkMem *types.Size `json:"logical_decoding_work_mem,omitempty" yaml:"logical_decoding_work_mem,omitempty" mapstructure:"logical_decoding_work_mem,omitempty"`

	// \N
	MaintenanceIoConcurrency *int `json:"maintenance_io_concurrency,omitempty" yaml:"maintenance_io_concurrency,omitempty" mapstructure:"maintenance_io_concurrency,omitempty"`

	// \N
	MaintenanceWorkMem *types.Size `json:"maintenance_work_mem,omitempty" yaml:"maintenance_work_mem,omitempty" mapstructure:"maintenance_work_mem,omitempty"`

	// \N
	MaxConnections *int `json:"max_connections,omitempty" yaml:"max_connections,omitempty" mapstructure:"max_connections,omitempty"`

	// \N
	MaxFilesPerProcess *int `json:"max_files_per_process,omitempty" yaml:"max_files_per_process,omitempty" mapstructure:"max_files_per_process,omitempty"`

	// \N
	MaxLocksPerTransaction *int `json:"max_locks_per_transaction,omitempty" yaml:"max_locks_per_transaction,omitempty" mapstructure:"max_locks_per_transaction,omitempty"`

	// \N
	MaxLogicalReplicationWorkers *int `json:"max_logical_replication_workers,omitempty" yaml:"max_logical_replication_workers,omitempty" mapstructure:"max_logical_replication_workers,omitempty"`

	// \N
	MaxNotifyQueuePages *int `json:"max_notify_queue_pages,omitempty" yaml:"max_notify_queue_pages,omitempty" mapstructure:"max_notify_queue_pages,omitempty"`

	// \N
	MaxParallelApplyWorkersPerSubscription *int `json:"max_parallel_apply_workers_per_subscription,omitempty" yaml:"max_parallel_apply_workers_per_subscription,omitempty" mapstructure:"max_parallel_apply_workers_per_subscription,omitempty"`

	// \N
	MaxParallelMaintenanceWorkers *int `json:"max_parallel_maintenance_workers,omitempty" yaml:"max_parallel_maintenance_workers,omitempty" mapstructure:"max_parallel_maintenance_workers,omitempty"`

	// \N
	MaxParallelWorkers *int `json:"max_parallel_workers,omitempty" yaml:"max_parallel_workers,omitempty" mapstructure:"max_parallel_workers,omitempty"`

	// \N
	MaxParallelWorkersPerGather *int `json:"max_parallel_workers_per_gather,omitempty" yaml:"max_parallel_workers_per_gather,omitempty" mapstructure:"max_parallel_workers_per_gather,omitempty"`

	// \N
	MaxPredLocksPerPage *int `json:"max_pred_locks_per_page,omitempty" yaml:"max_pred_locks_per_page,omitempty" mapstructure:"max_pred_locks_per_page,omitempty"`

	// \N
	MaxPredLocksPerRelation *int `json:"max_pred_locks_per_relation,omitempty" yaml:"max_pred_locks_per_relation,omitempty" mapstructure:"max_pred_locks_per_relation,omitempty"`

	// \N
	MaxPredLocksPerTransaction *int `json:"max_pred_locks_per_transaction,omitempty" yaml:"max_pred_locks_per_transaction,omitempty" mapstructure:"max_pred_locks_per_transaction,omitempty"`

	// \N
	MaxPreparedTransactions *int `json:"max_prepared_transactions,omitempty" yaml:"max_prepared_transactions,omitempty" mapstructure:"max_prepared_transactions,omitempty"`

	// \N
	MaxReplicationSlots *int `json:"max_replication_slots,omitempty" yaml:"max_replication_slots,omitempty" mapstructure:"max_replication_slots,omitempty"`

	// \N
	MaxSlotWalKeepSize *int `json:"max_slot_wal_keep_size,omitempty" yaml:"max_slot_wal_keep_size,omitempty" mapstructure:"max_slot_wal_keep_size,omitempty"`

	// \N
	MaxStackDepth *types.Size `json:"max_stack_depth,omitempty" yaml:"max_stack_depth,omitempty" mapstructure:"max_stack_depth,omitempty"`

	// \N
	MaxStandbyArchiveDelay *types.Duration `json:"max_standby_archive_delay,omitempty" yaml:"max_standby_archive_delay,omitempty" mapstructure:"max_standby_archive_delay,omitempty"`

	// \N
	MaxStandbyStreamingDelay *types.Duration `json:"max_standby_streaming_delay,omitempty" yaml:"max_standby_streaming_delay,omitempty" mapstructure:"max_standby_streaming_delay,omitempty"`

	// \N
	MaxSyncWorkersPerSubscription *int `json:"max_sync_workers_per_subscription,omitempty" yaml:"max_sync_workers_per_subscription,omitempty" mapstructure:"max_sync_workers_per_subscription,omitempty"`

	// \N
	MaxWalSenders *int `json:"max_wal_senders,omitempty" yaml:"max_wal_senders,omitempty" mapstructure:"max_wal_senders,omitempty"`

	// \N
	MaxWalSize *int `json:"max_wal_size,omitempty" yaml:"max_wal_size,omitempty" mapstructure:"max_wal_size,omitempty"`

	// \N
	MaxWorkerProcesses *int `json:"max_worker_processes,omitempty" yaml:"max_worker_processes,omitempty" mapstructure:"max_worker_processes,omitempty"`

	// \N
	MinDynamicSharedMemory *int `json:"min_dynamic_shared_memory,omitempty" yaml:"min_dynamic_shared_memory,omitempty" mapstructure:"min_dynamic_shared_memory,omitempty"`

	// \N
	MinParallelIndexScanSize *types.Size `json:"min_parallel_index_scan_size,omitempty" yaml:"min_parallel_index_scan_size,omitempty" mapstructure:"min_parallel_index_scan_size,omitempty"`

	// \N
	MinParallelTableScanSize *types.Size `json:"min_parallel_table_scan_size,omitempty" yaml:"min_parallel_table_scan_size,omitempty" mapstructure:"min_parallel_table_scan_size,omitempty"`

	// \N
	MinWalSize *int `json:"min_wal_size,omitempty" yaml:"min_wal_size,omitempty" mapstructure:"min_wal_size,omitempty"`

	// \N
	MultixactMemberBuffers *types.Size `json:"multixact_member_buffers,omitempty" yaml:"multixact_member_buffers,omitempty" mapstructure:"multixact_member_buffers,omitempty"`

	// \N
	MultixactOffsetBuffers *types.Size `json:"multixact_offset_buffers,omitempty" yaml:"multixact_offset_buffers,omitempty" mapstructure:"multixact_offset_buffers,omitempty"`

	// \N
	NotifyBuffers *types.Size `json:"notify_buffers,omitempty" yaml:"notify_buffers,omitempty" mapstructure:"notify_buffers,omitempty"`

	// \N
	ParallelLeaderParticipation *bool `json:"parallel_leader_participation,omitempty" yaml:"parallel_leader_participation,omitempty" mapstructure:"parallel_leader_participation,omitempty"`

	// \N
	ParallelSetupCost *float64 `json:"parallel_setup_cost,omitempty" yaml:"parallel_setup_cost,omitempty" mapstructure:"parallel_setup_cost,omitempty"`

	// \N
	ParallelTupleCost *float64 `json:"parallel_tuple_cost,omitempty" yaml:"parallel_tuple_cost,omitempty" mapstructure:"parallel_tuple_cost,omitempty"`

	// \N
	PasswordEncryption string `json:"password_encryption,omitempty" yaml:"password_encryption,omitempty" mapstructure:"password_encryption,omitempty"`

	// \N
	PlanCacheMode string `json:"plan_cache_mode,omitempty" yaml:"plan_cache_mode,omitempty" mapstructure:"plan_cache_mode,omitempty"`

	// \N
	Port *int `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`

	// \N
	PostAuthDelay *types.Duration `json:"post_auth_delay,omitempty" yaml:"post_auth_delay,omitempty" mapstructure:"post_auth_delay,omitempty"`

	// \N
	PreAuthDelay *types.Duration `json:"pre_auth_delay,omitempty" yaml:"pre_auth_delay,omitempty" mapstructure:"pre_auth_delay,omitempty"`

	// \N
	PrimaryConninfo *string `json:"primary_conninfo,omitempty" yaml:"primary_conninfo,omitempty" mapstructure:"primary_conninfo,omitempty"`

	// \N
	PrimarySlotName *string `json:"primary_slot_name,omitempty" yaml:"primary_slot_name,omitempty" mapstructure:"primary_slot_name,omitempty"`

	// \N
	QuoteAllIdentifiers *bool `json:"quote_all_identifiers,omitempty" yaml:"quote_all_identifiers,omitempty" mapstructure:"quote_all_identifiers,omitempty"`

	// \N
	RandomPageCost *float64 `json:"random_page_cost,omitempty" yaml:"random_page_cost,omitempty" mapstructure:"random_page_cost,omitempty"`

	// \N
	RecoveryEndCommand *string `json:"recovery_end_command,omitempty" yaml:"recovery_end_command,omitempty" mapstructure:"recovery_end_command,omitempty"`

	// \N
	RecoveryInitSyncMethod string `json:"recovery_init_sync_method,omitempty" yaml:"recovery_init_sync_method,omitempty" mapstructure:"recovery_init_sync_method,omitempty"`

	// \N
	RecoveryMinApplyDelay *types.Duration `json:"recovery_min_apply_delay,omitempty" yaml:"recovery_min_apply_delay,omitempty" mapstructure:"recovery_min_apply_delay,omitempty"`

	// \N
	RecoveryPrefetch string `json:"recovery_prefetch,omitempty" yaml:"recovery_prefetch,omitempty" mapstructure:"recovery_prefetch,omitempty"`

	// \N
	RecoveryTarget *string `json:"recovery_target,omitempty" yaml:"recovery_target,omitempty" mapstructure:"recovery_target,omitempty"`

	// \N
	RecoveryTargetAction string `json:"recovery_target_action,omitempty" yaml:"recovery_target_action,omitempty" mapstructure:"recovery_target_action,omitempty"`

	// \N
	RecoveryTargetInclusive *bool `json:"recovery_target_inclusive,omitempty" yaml:"recovery_target_inclusive,omitempty" mapstructure:"recovery_target_inclusive,omitempty"`

	// \N
	RecoveryTargetLsn *string `json:"recovery_target_lsn,omitempty" yaml:"recovery_target_lsn,omitempty" mapstructure:"recovery_target_lsn,omitempty"`

	// \N
	RecoveryTargetName *string `json:"recovery_target_name,omitempty" yaml:"recovery_target_name,omitempty" mapstructure:"recovery_target_name,omitempty"`

	// \N
	RecoveryTargetTime *string `json:"recovery_target_time,omitempty" yaml:"recovery_target_time,omitempty" mapstructure:"recovery_target_time,omitempty"`

	// \N
	RecoveryTargetTimeline *string `json:"recovery_target_timeline,omitempty" yaml:"recovery_target_timeline,omitempty" mapstructure:"recovery_target_timeline,omitempty"`

	// \N
	RecoveryTargetXid *string `json:"recovery_target_xid,omitempty" yaml:"recovery_target_xid,omitempty" mapstructure:"recovery_target_xid,omitempty"`

	// \N
	RecursiveWorktableFactor *float64 `json:"recursive_worktable_factor,omitempty" yaml:"recursive_worktable_factor,omitempty" mapstructure:"recursive_worktable_factor,omitempty"`

	// \N
	RemoveTempFilesAfterCrash *bool `json:"remove_temp_files_after_crash,omitempty" yaml:"remove_temp_files_after_crash,omitempty" mapstructure:"remove_temp_files_after_crash,omitempty"`

	// \N
	ReservedConnections *int `json:"reserved_connections,omitempty" yaml:"reserved_connections,omitempty" mapstructure:"reserved_connections,omitempty"`

	// \N
	RestartAfterCrash *bool `json:"restart_after_crash,omitempty" yaml:"restart_after_crash,omitempty" mapstructure:"restart_after_crash,omitempty"`

	// \N
	RestoreCommand *string `json:"restore_command,omitempty" yaml:"restore_command,omitempty" mapstructure:"restore_command,omitempty"`

	// \N
	RestrictNonsystemRelationKind *string `json:"restrict_nonsystem_relation_kind,omitempty" yaml:"restrict_nonsystem_relation_kind,omitempty" mapstructure:"restrict_nonsystem_relation_kind,omitempty"`

	// \N
	RowSecurity *bool `json:"row_security,omitempty" yaml:"row_security,omitempty" mapstructure:"row_security,omitempty"`

	// \N
	ScramIterations *int `json:"scram_iterations,omitempty" yaml:"scram_iterations,omitempty" mapstructure:"scram_iterations,omitempty"`

	// \N
	SearchPath *string `json:"search_path,omitempty" yaml:"search_path,omitempty" mapstructure:"search_path,omitempty"`

	// \N
	SendAbortForCrash *bool `json:"send_abort_for_crash,omitempty" yaml:"send_abort_for_crash,omitempty" mapstructure:"send_abort_for_crash,omitempty"`

	// \N
	SendAbortForKill *bool `json:"send_abort_for_kill,omitempty" yaml:"send_abort_for_kill,omitempty" mapstructure:"send_abort_for_kill,omitempty"`

	// \N
	SeqPageCost *float64 `json:"seq_page_cost,omitempty" yaml:"seq_page_cost,omitempty" mapstructure:"seq_page_cost,omitempty"`

	// \N
	SerializableBuffers *types.Size `json:"serializable_buffers,omitempty" yaml:"serializable_buffers,omitempty" mapstructure:"serializable_buffers,omitempty"`

	// \N
	SessionPreloadLibraries *string `json:"session_preload_libraries,omitempty" yaml:"session_preload_libraries,omitempty" mapstructure:"session_preload_libraries,omitempty"`

	// \N
	SessionReplicationRole string `json:"session_replication_role,omitempty" yaml:"session_replication_role,omitempty" mapstructure:"session_replication_role,omitempty"`

	// \N
	SharedBuffers *types.Size `json:"shared_buffers,omitempty" yaml:"shared_buffers,omitempty" mapstructure:"shared_buffers,omitempty"`

	// \N
	SharedMemoryType string `json:"shared_memory_type,omitempty" yaml:"shared_memory_type,omitempty" mapstructure:"shared_memory_type,omitempty"`

	// \N
	SharedPreloadLibraries *string `json:"shared_preload_libraries,omitempty" yaml:"shared_preload_libraries,omitempty" mapstructure:"shared_preload_libraries,omitempty"`

	// \N
	Ssl *bool `json:"ssl,omitempty" yaml:"ssl,omitempty" mapstructure:"ssl,omitempty"`

	// \N
	SslCaFile *string `json:"ssl_ca_file,omitempty" yaml:"ssl_ca_file,omitempty" mapstructure:"ssl_ca_file,omitempty"`

	// \N
	SslCertFile *string `json:"ssl_cert_file,omitempty" yaml:"ssl_cert_file,omitempty" mapstructure:"ssl_cert_file,omitempty"`

	// \N
	SslCiphers *string `json:"ssl_ciphers,omitempty" yaml:"ssl_ciphers,omitempty" mapstructure:"ssl_ciphers,omitempty"`

	// \N
	SslCrlDir *string `json:"ssl_crl_dir,omitempty" yaml:"ssl_crl_dir,omitempty" mapstructure:"ssl_crl_dir,omitempty"`

	// \N
	SslCrlFile *string `json:"ssl_crl_file,omitempty" yaml:"ssl_crl_file,omitempty" mapstructure:"ssl_crl_file,omitempty"`

	// \N
	SslDhParamsFile *string `json:"ssl_dh_params_file,omitempty" yaml:"ssl_dh_params_file,omitempty" mapstructure:"ssl_dh_params_file,omitempty"`

	// \N
	SslEcdhCurve *string `json:"ssl_ecdh_curve,omitempty" yaml:"ssl_ecdh_curve,omitempty" mapstructure:"ssl_ecdh_curve,omitempty"`

	// \N
	SslKeyFile *string `json:"ssl_key_file,omitempty" yaml:"ssl_key_file,omitempty" mapstructure:"ssl_key_file,omitempty"`

	// \N
	SslMaxProtocolVersion string `json:"ssl_max_protocol_version,omitempty" yaml:"ssl_max_protocol_version,omitempty" mapstructure:"ssl_max_protocol_version,omitempty"`

	// \N
	SslMinProtocolVersion string `json:"ssl_min_protocol_version,omitempty" yaml:"ssl_min_protocol_version,omitempty" mapstructure:"ssl_min_protocol_version,omitempty"`

	// \N
	SslPassphraseCommand *string `json:"ssl_passphrase_command,omitempty" yaml:"ssl_passphrase_command,omitempty" mapstructure:"ssl_passphrase_command,omitempty"`

	// \N
	SslPassphraseCommandSupportsReload *bool `json:"ssl_passphrase_command_supports_reload,omitempty" yaml:"ssl_passphrase_command_supports_reload,omitempty" mapstructure:"ssl_passphrase_command_supports_reload,omitempty"`

	// \N
	SslPreferServerCiphers *bool `json:"ssl_prefer_server_ciphers,omitempty" yaml:"ssl_prefer_server_ciphers,omitempty" mapstructure:"ssl_prefer_server_ciphers,omitempty"`

	// \N
	StandardConformingStrings *bool `json:"standard_conforming_strings,omitempty" yaml:"standard_conforming_strings,omitempty" mapstructure:"standard_conforming_strings,omitempty"`

	// \N
	StatementTimeout *types.Duration `json:"statement_timeout,omitempty" yaml:"statement_timeout,omitempty" mapstructure:"statement_timeout,omitempty"`

	// \N
	StatsFetchConsistency string `json:"stats_fetch_consistency,omitempty" yaml:"stats_fetch_consistency,omitempty" mapstructure:"stats_fetch_consistency,omitempty"`

	// \N
	SubtransactionBuffers *types.Size `json:"subtransaction_buffers,omitempty" yaml:"subtransaction_buffers,omitempty" mapstructure:"subtransaction_buffers,omitempty"`

	// \N
	SummarizeWal *bool `json:"summarize_wal,omitempty" yaml:"summarize_wal,omitempty" mapstructure:"summarize_wal,omitempty"`

	// \N
	SuperuserReservedConnections *int `json:"superuser_reserved_connections,omitempty" yaml:"superuser_reserved_connections,omitempty" mapstructure:"superuser_reserved_connections,omitempty"`

	// \N
	SyncReplicationSlots *bool `json:"sync_replication_slots,omitempty" yaml:"sync_replication_slots,omitempty" mapstructure:"sync_replication_slots,omitempty"`

	// \N
	SynchronizeSeqscans *bool `json:"synchronize_seqscans,omitempty" yaml:"synchronize_seqscans,omitempty" mapstructure:"synchronize_seqscans,omitempty"`

	// \N
	SynchronizedStandbySlots *string `json:"synchronized_standby_slots,omitempty" yaml:"synchronized_standby_slots,omitempty" mapstructure:"synchronized_standby_slots,omitempty"`

	// \N
	SynchronousCommit string `json:"synchronous_commit,omitempty" yaml:"synchronous_commit,omitempty" mapstructure:"synchronous_commit,omitempty"`

	// \N
	SynchronousStandbyNames *string `json:"synchronous_standby_names,omitempty" yaml:"synchronous_standby_names,omitempty" mapstructure:"synchronous_standby_names,omitempty"`

	// \N
	SyslogFacility string `json:"syslog_facility,omitempty" yaml:"syslog_facility,omitempty" mapstructure:"syslog_facility,omitempty"`

	// \N
	SyslogIdent *string `json:"syslog_ident,omitempty" yaml:"syslog_ident,omitempty" mapstructure:"syslog_ident,omitempty"`

	// \N
	SyslogSequenceNumbers *bool `json:"syslog_sequence_numbers,omitempty" yaml:"syslog_sequence_numbers,omitempty" mapstructure:"syslog_sequence_numbers,omitempty"`

	// \N
	SyslogSplitMessages *bool `json:"syslog_split_messages,omitempty" yaml:"syslog_split_messages,omitempty" mapstructure:"syslog_split_messages,omitempty"`

	// \N
	TcpKeepalivesCount *int `json:"tcp_keepalives_count,omitempty" yaml:"tcp_keepalives_count,omitempty" mapstructure:"tcp_keepalives_count,omitempty"`

	// \N
	TcpKeepalivesIdle *types.Duration `json:"tcp_keepalives_idle,omitempty" yaml:"tcp_keepalives_idle,omitempty" mapstructure:"tcp_keepalives_idle,omitempty"`

	// \N
	TcpKeepalivesInterval *types.Duration `json:"tcp_keepalives_interval,omitempty" yaml:"tcp_keepalives_interval,omitempty" mapstructure:"tcp_keepalives_interval,omitempty"`

	// \N
	TcpUserTimeout *types.Duration `json:"tcp_user_timeout,omitempty" yaml:"tcp_user_timeout,omitempty" mapstructure:"tcp_user_timeout,omitempty"`

	// \N
	TempBuffers *types.Size `json:"temp_buffers,omitempty" yaml:"temp_buffers,omitempty" mapstructure:"temp_buffers,omitempty"`

	// \N
	TempFileLimit *types.Size `json:"temp_file_limit,omitempty" yaml:"temp_file_limit,omitempty" mapstructure:"temp_file_limit,omitempty"`

	// \N
	TempTablespaces *string `json:"temp_tablespaces,omitempty" yaml:"temp_tablespaces,omitempty" mapstructure:"temp_tablespaces,omitempty"`

	// \N
	TimezoneAbbreviations *string `json:"timezone_abbreviations,omitempty" yaml:"timezone_abbreviations,omitempty" mapstructure:"timezone_abbreviations,omitempty"`

	// \N
	TraceNotify *bool `json:"trace_notify,omitempty" yaml:"trace_notify,omitempty" mapstructure:"trace_notify,omitempty"`

	// \N
	TraceSort *bool `json:"trace_sort,omitempty" yaml:"trace_sort,omitempty" mapstructure:"trace_sort,omitempty"`

	// \N
	TrackActivities *bool `json:"track_activities,omitempty" yaml:"track_activities,omitempty" mapstructure:"track_activities,omitempty"`

	// \N
	TrackActivityQuerySize *int `json:"track_activity_query_size,omitempty" yaml:"track_activity_query_size,omitempty" mapstructure:"track_activity_query_size,omitempty"`

	// \N
	TrackCommitTimestamp *bool `json:"track_commit_timestamp,omitempty" yaml:"track_commit_timestamp,omitempty" mapstructure:"track_commit_timestamp,omitempty"`

	// \N
	TrackCounts *bool `json:"track_counts,omitempty" yaml:"track_counts,omitempty" mapstructure:"track_counts,omitempty"`

	// \N
	TrackFunctions string `json:"track_functions,omitempty" yaml:"track_functions,omitempty" mapstructure:"track_functions,omitempty"`

	// \N
	TrackIoTiming *bool `json:"track_io_timing,omitempty" yaml:"track_io_timing,omitempty" mapstructure:"track_io_timing,omitempty"`

	// \N
	TrackWalIoTiming *bool `json:"track_wal_io_timing,omitempty" yaml:"track_wal_io_timing,omitempty" mapstructure:"track_wal_io_timing,omitempty"`

	// \N
	TransactionBuffers *types.Size `json:"transaction_buffers,omitempty" yaml:"transaction_buffers,omitempty" mapstructure:"transaction_buffers,omitempty"`

	// \N
	TransactionDeferrable *bool `json:"transaction_deferrable,omitempty" yaml:"transaction_deferrable,omitempty" mapstructure:"transaction_deferrable,omitempty"`

	// \N
	TransactionIsolation string `json:"transaction_isolation,omitempty" yaml:"transaction_isolation,omitempty" mapstructure:"transaction_isolation,omitempty"`

	// \N
	TransactionReadOnly *bool `json:"transaction_read_only,omitempty" yaml:"transaction_read_only,omitempty" mapstructure:"transaction_read_only,omitempty"`

	// \N
	TransactionTimeout *types.Duration `json:"transaction_timeout,omitempty" yaml:"transaction_timeout,omitempty" mapstructure:"transaction_timeout,omitempty"`

	// \N
	TransformNullEquals *bool `json:"transform_null_equals,omitempty" yaml:"transform_null_equals,omitempty" mapstructure:"transform_null_equals,omitempty"`

	// \N
	UnixSocketDirectories *string `json:"unix_socket_directories,omitempty" yaml:"unix_socket_directories,omitempty" mapstructure:"unix_socket_directories,omitempty"`

	// \N
	UnixSocketGroup *string `json:"unix_socket_group,omitempty" yaml:"unix_socket_group,omitempty" mapstructure:"unix_socket_group,omitempty"`

	// \N
	UnixSocketPermissions *int `json:"unix_socket_permissions,omitempty" yaml:"unix_socket_permissions,omitempty" mapstructure:"unix_socket_permissions,omitempty"`

	// \N
	UpdateProcessTitle *bool `json:"update_process_title,omitempty" yaml:"update_process_title,omitempty" mapstructure:"update_process_title,omitempty"`

	// \N
	VacuumBufferUsageLimit *types.Size `json:"vacuum_buffer_usage_limit,omitempty" yaml:"vacuum_buffer_usage_limit,omitempty" mapstructure:"vacuum_buffer_usage_limit,omitempty"`

	// \N
	VacuumCostDelay *types.Duration `json:"vacuum_cost_delay,omitempty" yaml:"vacuum_cost_delay,omitempty" mapstructure:"vacuum_cost_delay,omitempty"`

	// \N
	VacuumCostLimit *int `json:"vacuum_cost_limit,omitempty" yaml:"vacuum_cost_limit,omitempty" mapstructure:"vacuum_cost_limit,omitempty"`

	// \N
	VacuumCostPageDirty *int `json:"vacuum_cost_page_dirty,omitempty" yaml:"vacuum_cost_page_dirty,omitempty" mapstructure:"vacuum_cost_page_dirty,omitempty"`

	// \N
	VacuumCostPageHit *int `json:"vacuum_cost_page_hit,omitempty" yaml:"vacuum_cost_page_hit,omitempty" mapstructure:"vacuum_cost_page_hit,omitempty"`

	// \N
	VacuumCostPageMiss *int `json:"vacuum_cost_page_miss,omitempty" yaml:"vacuum_cost_page_miss,omitempty" mapstructure:"vacuum_cost_page_miss,omitempty"`

	// \N
	VacuumFailsafeAge *int `json:"vacuum_failsafe_age,omitempty" yaml:"vacuum_failsafe_age,omitempty" mapstructure:"vacuum_failsafe_age,omitempty"`

	// \N
	VacuumFreezeMinAge *int `json:"vacuum_freeze_min_age,omitempty" yaml:"vacuum_freeze_min_age,omitempty" mapstructure:"vacuum_freeze_min_age,omitempty"`

	// \N
	VacuumFreezeTableAge *int `json:"vacuum_freeze_table_age,omitempty" yaml:"vacuum_freeze_table_age,omitempty" mapstructure:"vacuum_freeze_table_age,omitempty"`

	// \N
	VacuumMultixactFailsafeAge *int `json:"vacuum_multixact_failsafe_age,omitempty" yaml:"vacuum_multixact_failsafe_age,omitempty" mapstructure:"vacuum_multixact_failsafe_age,omitempty"`

	// \N
	VacuumMultixactFreezeMinAge *int `json:"vacuum_multixact_freeze_min_age,omitempty" yaml:"vacuum_multixact_freeze_min_age,omitempty" mapstructure:"vacuum_multixact_freeze_min_age,omitempty"`

	// \N
	VacuumMultixactFreezeTableAge *int `json:"vacuum_multixact_freeze_table_age,omitempty" yaml:"vacuum_multixact_freeze_table_age,omitempty" mapstructure:"vacuum_multixact_freeze_table_age,omitempty"`

	// \N
	WalBuffers *types.Size `json:"wal_buffers,omitempty" yaml:"wal_buffers,omitempty" mapstructure:"wal_buffers,omitempty"`

	// \N
	WalCompression string `json:"wal_compression,omitempty" yaml:"wal_compression,omitempty" mapstructure:"wal_compression,omitempty"`

	// \N
	WalConsistencyChecking *string `json:"wal_consistency_checking,omitempty" yaml:"wal_consistency_checking,omitempty" mapstructure:"wal_consistency_checking,omitempty"`

	// \N
	WalDecodeBufferSize *int `json:"wal_decode_buffer_size,omitempty" yaml:"wal_decode_buffer_size,omitempty" mapstructure:"wal_decode_buffer_size,omitempty"`

	// \N
	WalInitZero *bool `json:"wal_init_zero,omitempty" yaml:"wal_init_zero,omitempty" mapstructure:"wal_init_zero,omitempty"`

	// \N
	WalKeepSize *int `json:"wal_keep_size,omitempty" yaml:"wal_keep_size,omitempty" mapstructure:"wal_keep_size,omitempty"`

	// \N
	WalLevel string `json:"wal_level,omitempty" yaml:"wal_level,omitempty" mapstructure:"wal_level,omitempty"`

	// \N
	WalLogHints *bool `json:"wal_log_hints,omitempty" yaml:"wal_log_hints,omitempty" mapstructure:"wal_log_hints,omitempty"`

	// \N
	WalReceiverCreateTempSlot *bool `json:"wal_receiver_create_temp_slot,omitempty" yaml:"wal_receiver_create_temp_slot,omitempty" mapstructure:"wal_receiver_create_temp_slot,omitempty"`

	// \N
	WalReceiverStatusInterval *types.Duration `json:"wal_receiver_status_interval,omitempty" yaml:"wal_receiver_status_interval,omitempty" mapstructure:"wal_receiver_status_interval,omitempty"`

	// \N
	WalReceiverTimeout *types.Duration `json:"wal_receiver_timeout,omitempty" yaml:"wal_receiver_timeout,omitempty" mapstructure:"wal_receiver_timeout,omitempty"`

	// \N
	WalRecycle *bool `json:"wal_recycle,omitempty" yaml:"wal_recycle,omitempty" mapstructure:"wal_recycle,omitempty"`

	// \N
	WalRetrieveRetryInterval *types.Duration `json:"wal_retrieve_retry_interval,omitempty" yaml:"wal_retrieve_retry_interval,omitempty" mapstructure:"wal_retrieve_retry_interval,omitempty"`

	// \N
	WalSenderTimeout *types.Duration `json:"wal_sender_timeout,omitempty" yaml:"wal_sender_timeout,omitempty" mapstructure:"wal_sender_timeout,omitempty"`

	// \N
	WalSkipThreshold *types.Size `json:"wal_skip_threshold,omitempty" yaml:"wal_skip_threshold,omitempty" mapstructure:"wal_skip_threshold,omitempty"`

	// \N
	WalSummaryKeepTime *types.Duration `json:"wal_summary_keep_time,omitempty" yaml:"wal_summary_keep_time,omitempty" mapstructure:"wal_summary_keep_time,omitempty"`

	// \N
	WalSyncMethod string `json:"wal_sync_method,omitempty" yaml:"wal_sync_method,omitempty" mapstructure:"wal_sync_method,omitempty"`

	// \N
	WalWriterDelay *types.Duration `json:"wal_writer_delay,omitempty" yaml:"wal_writer_delay,omitempty" mapstructure:"wal_writer_delay,omitempty"`

	// \N
	WalWriterFlushAfter *types.Size `json:"wal_writer_flush_after,omitempty" yaml:"wal_writer_flush_after,omitempty" mapstructure:"wal_writer_flush_after,omitempty"`

	// \N
	WorkMem *types.Size `json:"work_mem,omitempty" yaml:"work_mem,omitempty" mapstructure:"work_mem,omitempty"`

	// \N
	Xmlbinary string `json:"xmlbinary,omitempty" yaml:"xmlbinary,omitempty" mapstructure:"xmlbinary,omitempty"`

	// \N
	Xmloption string `json:"xmloption,omitempty" yaml:"xmloption,omitempty" mapstructure:"xmloption,omitempty"`

	// \N
	ZeroDamagedPages *bool `json:"zero_damaged_pages,omitempty" yaml:"zero_damaged_pages,omitempty" mapstructure:"zero_damaged_pages,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PostgresConf) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain PostgresConf
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["IntervalStyle"]; !ok || v == nil {
		plain.IntervalStyle = "{postgres,postgres_verbose,sql_standard,iso_8601}"
	}
	if v, ok := raw["archive_mode"]; !ok || v == nil {
		plain.ArchiveMode = "{always,on,off}"
	}
	if plain.AutovacuumAnalyzeScaleFactor != nil && 100 < *plain.AutovacuumAnalyzeScaleFactor {
		return fmt.Errorf("field %s: must be <= %v", "autovacuum_analyze_scale_factor", 100)
	}
	if plain.AutovacuumAnalyzeThreshold != nil && 2147483647 < *plain.AutovacuumAnalyzeThreshold {
		return fmt.Errorf("field %s: must be <= %v", "autovacuum_analyze_threshold", 2147483647)
	}
	if plain.AutovacuumFreezeMaxAge != nil && 2000000000 < *plain.AutovacuumFreezeMaxAge {
		return fmt.Errorf("field %s: must be <= %v", "autovacuum_freeze_max_age", 2000000000)
	}
	if plain.AutovacuumFreezeMaxAge != nil && 100000 > *plain.AutovacuumFreezeMaxAge {
		return fmt.Errorf("field %s: must be >= %v", "autovacuum_freeze_max_age", 100000)
	}
	if plain.AutovacuumMaxWorkers != nil && 262143 < *plain.AutovacuumMaxWorkers {
		return fmt.Errorf("field %s: must be <= %v", "autovacuum_max_workers", 262143)
	}
	if plain.AutovacuumMaxWorkers != nil && 1 > *plain.AutovacuumMaxWorkers {
		return fmt.Errorf("field %s: must be >= %v", "autovacuum_max_workers", 1)
	}
	if plain.AutovacuumMultixactFreezeMaxAge != nil && 2000000000 < *plain.AutovacuumMultixactFreezeMaxAge {
		return fmt.Errorf("field %s: must be <= %v", "autovacuum_multixact_freeze_max_age", 2000000000)
	}
	if plain.AutovacuumMultixactFreezeMaxAge != nil && 10000 > *plain.AutovacuumMultixactFreezeMaxAge {
		return fmt.Errorf("field %s: must be >= %v", "autovacuum_multixact_freeze_max_age", 10000)
	}
	if plain.AutovacuumVacuumCostLimit != nil && 10000 < *plain.AutovacuumVacuumCostLimit {
		return fmt.Errorf("field %s: must be <= %v", "autovacuum_vacuum_cost_limit", 10000)
	}
	if plain.AutovacuumVacuumCostLimit != nil && -1 > *plain.AutovacuumVacuumCostLimit {
		return fmt.Errorf("field %s: must be >= %v", "autovacuum_vacuum_cost_limit", -1)
	}
	if plain.AutovacuumVacuumInsertScaleFactor != nil && 100 < *plain.AutovacuumVacuumInsertScaleFactor {
		return fmt.Errorf("field %s: must be <= %v", "autovacuum_vacuum_insert_scale_factor", 100)
	}
	if plain.AutovacuumVacuumInsertThreshold != nil && 2147483647 < *plain.AutovacuumVacuumInsertThreshold {
		return fmt.Errorf("field %s: must be <= %v", "autovacuum_vacuum_insert_threshold", 2147483647)
	}
	if plain.AutovacuumVacuumInsertThreshold != nil && -1 > *plain.AutovacuumVacuumInsertThreshold {
		return fmt.Errorf("field %s: must be >= %v", "autovacuum_vacuum_insert_threshold", -1)
	}
	if plain.AutovacuumVacuumScaleFactor != nil && 100 < *plain.AutovacuumVacuumScaleFactor {
		return fmt.Errorf("field %s: must be <= %v", "autovacuum_vacuum_scale_factor", 100)
	}
	if plain.AutovacuumVacuumThreshold != nil && 2147483647 < *plain.AutovacuumVacuumThreshold {
		return fmt.Errorf("field %s: must be <= %v", "autovacuum_vacuum_threshold", 2147483647)
	}
	if plain.AutovacuumWorkMem != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.AutovacuumWorkMem.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "AutovacuumWorkMem", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.BackendFlushAfter != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.BackendFlushAfter.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "BackendFlushAfter", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if v, ok := raw["backslash_quote"]; !ok || v == nil {
		plain.BackslashQuote = "{safe_encoding,on,off}"
	}
	if plain.BgwriterFlushAfter != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.BgwriterFlushAfter.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "BgwriterFlushAfter", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.BgwriterLruMaxpages != nil && 1073741823 < *plain.BgwriterLruMaxpages {
		return fmt.Errorf("field %s: must be <= %v", "bgwriter_lru_maxpages", 1073741823)
	}
	if plain.BgwriterLruMultiplier != nil && 10 < *plain.BgwriterLruMultiplier {
		return fmt.Errorf("field %s: must be <= %v", "bgwriter_lru_multiplier", 10)
	}
	if v, ok := raw["bytea_output"]; !ok || v == nil {
		plain.ByteaOutput = "{escape,hex}"
	}
	if plain.CheckpointCompletionTarget != nil && 1 < *plain.CheckpointCompletionTarget {
		return fmt.Errorf("field %s: must be <= %v", "checkpoint_completion_target", 1)
	}
	if plain.CheckpointFlushAfter != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.CheckpointFlushAfter.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "CheckpointFlushAfter", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if v, ok := raw["client_min_messages"]; !ok || v == nil {
		plain.ClientMinMessages = "{debug5,debug4,debug3,debug2,debug1,log,notice,warning,error}"
	}
	if plain.CommitDelay != nil && 100000 < *plain.CommitDelay {
		return fmt.Errorf("field %s: must be <= %v", "commit_delay", 100000)
	}
	if plain.CommitSiblings != nil && 1000 < *plain.CommitSiblings {
		return fmt.Errorf("field %s: must be <= %v", "commit_siblings", 1000)
	}
	if plain.CommitTimestampBuffers != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.CommitTimestampBuffers.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "CommitTimestampBuffers", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if v, ok := raw["compute_query_id"]; !ok || v == nil {
		plain.ComputeQueryId = "{auto,regress,on,off}"
	}
	if v, ok := raw["constraint_exclusion"]; !ok || v == nil {
		plain.ConstraintExclusion = "{partition,on,off}"
	}
	if plain.CpuIndexTupleCost != nil && 1.79769e+308 < *plain.CpuIndexTupleCost {
		return fmt.Errorf("field %s: must be <= %v", "cpu_index_tuple_cost", 1.79769e+308)
	}
	if plain.CpuOperatorCost != nil && 1.79769e+308 < *plain.CpuOperatorCost {
		return fmt.Errorf("field %s: must be <= %v", "cpu_operator_cost", 1.79769e+308)
	}
	if plain.CpuTupleCost != nil && 1.79769e+308 < *plain.CpuTupleCost {
		return fmt.Errorf("field %s: must be <= %v", "cpu_tuple_cost", 1.79769e+308)
	}
	if plain.CursorTupleFraction != nil && 1 < *plain.CursorTupleFraction {
		return fmt.Errorf("field %s: must be <= %v", "cursor_tuple_fraction", 1)
	}
	if v, ok := raw["debug_logical_replication_streaming"]; !ok || v == nil {
		plain.DebugLogicalReplicationStreaming = "{buffered,immediate}"
	}
	if v, ok := raw["debug_parallel_query"]; !ok || v == nil {
		plain.DebugParallelQuery = "{off,on,regress}"
	}
	if plain.DefaultStatisticsTarget != nil && 10000 < *plain.DefaultStatisticsTarget {
		return fmt.Errorf("field %s: must be <= %v", "default_statistics_target", 10000)
	}
	if plain.DefaultStatisticsTarget != nil && 1 > *plain.DefaultStatisticsTarget {
		return fmt.Errorf("field %s: must be >= %v", "default_statistics_target", 1)
	}
	if v, ok := raw["default_toast_compression"]; !ok || v == nil {
		plain.DefaultToastCompression = "{pglz,lz4}"
	}
	if v, ok := raw["default_transaction_isolation"]; !ok || v == nil {
		plain.DefaultTransactionIsolation = "{serializable,repeatable read,read committed,read uncommitted}"
	}
	if v, ok := raw["dynamic_shared_memory_type"]; !ok || v == nil {
		plain.DynamicSharedMemoryType = "{posix,sysv,mmap}"
	}
	if plain.EffectiveCacheSize != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.EffectiveCacheSize.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "EffectiveCacheSize", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.EffectiveIoConcurrency != nil && 1000 < *plain.EffectiveIoConcurrency {
		return fmt.Errorf("field %s: must be <= %v", "effective_io_concurrency", 1000)
	}
	if plain.ExtraFloatDigits != nil && 3 < *plain.ExtraFloatDigits {
		return fmt.Errorf("field %s: must be <= %v", "extra_float_digits", 3)
	}
	if plain.ExtraFloatDigits != nil && -15 > *plain.ExtraFloatDigits {
		return fmt.Errorf("field %s: must be >= %v", "extra_float_digits", -15)
	}
	if plain.FromCollapseLimit != nil && 2147483647 < *plain.FromCollapseLimit {
		return fmt.Errorf("field %s: must be <= %v", "from_collapse_limit", 2147483647)
	}
	if plain.FromCollapseLimit != nil && 1 > *plain.FromCollapseLimit {
		return fmt.Errorf("field %s: must be >= %v", "from_collapse_limit", 1)
	}
	if plain.GeqoEffort != nil && 10 < *plain.GeqoEffort {
		return fmt.Errorf("field %s: must be <= %v", "geqo_effort", 10)
	}
	if plain.GeqoEffort != nil && 1 > *plain.GeqoEffort {
		return fmt.Errorf("field %s: must be >= %v", "geqo_effort", 1)
	}
	if plain.GeqoGenerations != nil && 2147483647 < *plain.GeqoGenerations {
		return fmt.Errorf("field %s: must be <= %v", "geqo_generations", 2147483647)
	}
	if plain.GeqoPoolSize != nil && 2147483647 < *plain.GeqoPoolSize {
		return fmt.Errorf("field %s: must be <= %v", "geqo_pool_size", 2147483647)
	}
	if plain.GeqoSeed != nil && 1 < *plain.GeqoSeed {
		return fmt.Errorf("field %s: must be <= %v", "geqo_seed", 1)
	}
	if plain.GeqoSelectionBias != nil && 2 < *plain.GeqoSelectionBias {
		return fmt.Errorf("field %s: must be <= %v", "geqo_selection_bias", 2)
	}
	if plain.GeqoSelectionBias != nil && 2 > *plain.GeqoSelectionBias {
		return fmt.Errorf("field %s: must be >= %v", "geqo_selection_bias", 2)
	}
	if plain.GeqoThreshold != nil && 2147483647 < *plain.GeqoThreshold {
		return fmt.Errorf("field %s: must be <= %v", "geqo_threshold", 2147483647)
	}
	if plain.GeqoThreshold != nil && 2 > *plain.GeqoThreshold {
		return fmt.Errorf("field %s: must be >= %v", "geqo_threshold", 2)
	}
	if plain.GinFuzzySearchLimit != nil && 2147483647 < *plain.GinFuzzySearchLimit {
		return fmt.Errorf("field %s: must be <= %v", "gin_fuzzy_search_limit", 2147483647)
	}
	if plain.GinPendingListLimit != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.GinPendingListLimit.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "GinPendingListLimit", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.HashMemMultiplier != nil && 1000 < *plain.HashMemMultiplier {
		return fmt.Errorf("field %s: must be <= %v", "hash_mem_multiplier", 1000)
	}
	if plain.HashMemMultiplier != nil && 1 > *plain.HashMemMultiplier {
		return fmt.Errorf("field %s: must be >= %v", "hash_mem_multiplier", 1)
	}
	if plain.HugePageSize != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.HugePageSize.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "HugePageSize", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if v, ok := raw["huge_pages"]; !ok || v == nil {
		plain.HugePages = "{off,on,try}"
	}
	if v, ok := raw["icu_validation_level"]; !ok || v == nil {
		plain.IcuValidationLevel = "{disabled,debug5,debug4,debug3,debug2,debug1,log,notice,warning,error}"
	}
	if plain.IoCombineLimit != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.IoCombineLimit.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "IoCombineLimit", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.JitAboveCost != nil && 1.79769e+308 < *plain.JitAboveCost {
		return fmt.Errorf("field %s: must be <= %v", "jit_above_cost", 1.79769e+308)
	}
	if plain.JitAboveCost != nil && -1 > *plain.JitAboveCost {
		return fmt.Errorf("field %s: must be >= %v", "jit_above_cost", -1)
	}
	if plain.JitInlineAboveCost != nil && 1.79769e+308 < *plain.JitInlineAboveCost {
		return fmt.Errorf("field %s: must be <= %v", "jit_inline_above_cost", 1.79769e+308)
	}
	if plain.JitInlineAboveCost != nil && -1 > *plain.JitInlineAboveCost {
		return fmt.Errorf("field %s: must be >= %v", "jit_inline_above_cost", -1)
	}
	if plain.JitOptimizeAboveCost != nil && 1.79769e+308 < *plain.JitOptimizeAboveCost {
		return fmt.Errorf("field %s: must be <= %v", "jit_optimize_above_cost", 1.79769e+308)
	}
	if plain.JitOptimizeAboveCost != nil && -1 > *plain.JitOptimizeAboveCost {
		return fmt.Errorf("field %s: must be >= %v", "jit_optimize_above_cost", -1)
	}
	if plain.JoinCollapseLimit != nil && 2147483647 < *plain.JoinCollapseLimit {
		return fmt.Errorf("field %s: must be <= %v", "join_collapse_limit", 2147483647)
	}
	if plain.JoinCollapseLimit != nil && 1 > *plain.JoinCollapseLimit {
		return fmt.Errorf("field %s: must be >= %v", "join_collapse_limit", 1)
	}
	if v, ok := raw["log_error_verbosity"]; !ok || v == nil {
		plain.LogErrorVerbosity = "{terse,default,verbose}"
	}
	if plain.LogFileMode != nil && 511 < *plain.LogFileMode {
		return fmt.Errorf("field %s: must be <= %v", "log_file_mode", 511)
	}
	if v, ok := raw["log_min_error_statement"]; !ok || v == nil {
		plain.LogMinErrorStatement = "{debug5,debug4,debug3,debug2,debug1,info,notice,warning,error,log,fatal,panic}"
	}
	if v, ok := raw["log_min_messages"]; !ok || v == nil {
		plain.LogMinMessages = "{debug5,debug4,debug3,debug2,debug1,info,notice,warning,error,log,fatal,panic}"
	}
	if plain.LogParameterMaxLength != nil && 1073741823 < *plain.LogParameterMaxLength {
		return fmt.Errorf("field %s: must be <= %v", "log_parameter_max_length", 1073741823)
	}
	if plain.LogParameterMaxLength != nil && -1 > *plain.LogParameterMaxLength {
		return fmt.Errorf("field %s: must be >= %v", "log_parameter_max_length", -1)
	}
	if plain.LogParameterMaxLengthOnError != nil && 1073741823 < *plain.LogParameterMaxLengthOnError {
		return fmt.Errorf("field %s: must be <= %v", "log_parameter_max_length_on_error", 1073741823)
	}
	if plain.LogParameterMaxLengthOnError != nil && -1 > *plain.LogParameterMaxLengthOnError {
		return fmt.Errorf("field %s: must be >= %v", "log_parameter_max_length_on_error", -1)
	}
	if plain.LogRotationSize != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.LogRotationSize.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "LogRotationSize", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if v, ok := raw["log_statement"]; !ok || v == nil {
		plain.LogStatement = "{none,ddl,mod,all}"
	}
	if plain.LogStatementSampleRate != nil && 1 < *plain.LogStatementSampleRate {
		return fmt.Errorf("field %s: must be <= %v", "log_statement_sample_rate", 1)
	}
	if plain.LogTempFiles != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.LogTempFiles.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "LogTempFiles", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.LogTransactionSampleRate != nil && 1 < *plain.LogTransactionSampleRate {
		return fmt.Errorf("field %s: must be <= %v", "log_transaction_sample_rate", 1)
	}
	if plain.LogicalDecodingWorkMem != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.LogicalDecodingWorkMem.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "LogicalDecodingWorkMem", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.MaintenanceIoConcurrency != nil && 1000 < *plain.MaintenanceIoConcurrency {
		return fmt.Errorf("field %s: must be <= %v", "maintenance_io_concurrency", 1000)
	}
	if plain.MaintenanceWorkMem != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.MaintenanceWorkMem.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MaintenanceWorkMem", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.MaxConnections != nil && 262143 < *plain.MaxConnections {
		return fmt.Errorf("field %s: must be <= %v", "max_connections", 262143)
	}
	if plain.MaxConnections != nil && 1 > *plain.MaxConnections {
		return fmt.Errorf("field %s: must be >= %v", "max_connections", 1)
	}
	if plain.MaxFilesPerProcess != nil && 2147483647 < *plain.MaxFilesPerProcess {
		return fmt.Errorf("field %s: must be <= %v", "max_files_per_process", 2147483647)
	}
	if plain.MaxFilesPerProcess != nil && 64 > *plain.MaxFilesPerProcess {
		return fmt.Errorf("field %s: must be >= %v", "max_files_per_process", 64)
	}
	if plain.MaxLocksPerTransaction != nil && 2147483647 < *plain.MaxLocksPerTransaction {
		return fmt.Errorf("field %s: must be <= %v", "max_locks_per_transaction", 2147483647)
	}
	if plain.MaxLocksPerTransaction != nil && 10 > *plain.MaxLocksPerTransaction {
		return fmt.Errorf("field %s: must be >= %v", "max_locks_per_transaction", 10)
	}
	if plain.MaxLogicalReplicationWorkers != nil && 262143 < *plain.MaxLogicalReplicationWorkers {
		return fmt.Errorf("field %s: must be <= %v", "max_logical_replication_workers", 262143)
	}
	if plain.MaxNotifyQueuePages != nil && 2147483647 < *plain.MaxNotifyQueuePages {
		return fmt.Errorf("field %s: must be <= %v", "max_notify_queue_pages", 2147483647)
	}
	if plain.MaxNotifyQueuePages != nil && 64 > *plain.MaxNotifyQueuePages {
		return fmt.Errorf("field %s: must be >= %v", "max_notify_queue_pages", 64)
	}
	if plain.MaxParallelApplyWorkersPerSubscription != nil && 1024 < *plain.MaxParallelApplyWorkersPerSubscription {
		return fmt.Errorf("field %s: must be <= %v", "max_parallel_apply_workers_per_subscription", 1024)
	}
	if plain.MaxParallelMaintenanceWorkers != nil && 1024 < *plain.MaxParallelMaintenanceWorkers {
		return fmt.Errorf("field %s: must be <= %v", "max_parallel_maintenance_workers", 1024)
	}
	if plain.MaxParallelWorkers != nil && 1024 < *plain.MaxParallelWorkers {
		return fmt.Errorf("field %s: must be <= %v", "max_parallel_workers", 1024)
	}
	if plain.MaxParallelWorkersPerGather != nil && 1024 < *plain.MaxParallelWorkersPerGather {
		return fmt.Errorf("field %s: must be <= %v", "max_parallel_workers_per_gather", 1024)
	}
	if plain.MaxPredLocksPerPage != nil && 2147483647 < *plain.MaxPredLocksPerPage {
		return fmt.Errorf("field %s: must be <= %v", "max_pred_locks_per_page", 2147483647)
	}
	if plain.MaxPredLocksPerRelation != nil && 2147483647 < *plain.MaxPredLocksPerRelation {
		return fmt.Errorf("field %s: must be <= %v", "max_pred_locks_per_relation", 2147483647)
	}
	if plain.MaxPredLocksPerRelation != nil && -2147483648 > *plain.MaxPredLocksPerRelation {
		return fmt.Errorf("field %s: must be >= %v", "max_pred_locks_per_relation", -2147483648)
	}
	if plain.MaxPredLocksPerTransaction != nil && 2147483647 < *plain.MaxPredLocksPerTransaction {
		return fmt.Errorf("field %s: must be <= %v", "max_pred_locks_per_transaction", 2147483647)
	}
	if plain.MaxPredLocksPerTransaction != nil && 10 > *plain.MaxPredLocksPerTransaction {
		return fmt.Errorf("field %s: must be >= %v", "max_pred_locks_per_transaction", 10)
	}
	if plain.MaxPreparedTransactions != nil && 262143 < *plain.MaxPreparedTransactions {
		return fmt.Errorf("field %s: must be <= %v", "max_prepared_transactions", 262143)
	}
	if plain.MaxReplicationSlots != nil && 262143 < *plain.MaxReplicationSlots {
		return fmt.Errorf("field %s: must be <= %v", "max_replication_slots", 262143)
	}
	if plain.MaxSlotWalKeepSize != nil && 2147483647 < *plain.MaxSlotWalKeepSize {
		return fmt.Errorf("field %s: must be <= %v", "max_slot_wal_keep_size", 2147483647)
	}
	if plain.MaxSlotWalKeepSize != nil && -1 > *plain.MaxSlotWalKeepSize {
		return fmt.Errorf("field %s: must be >= %v", "max_slot_wal_keep_size", -1)
	}
	if plain.MaxStackDepth != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.MaxStackDepth.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MaxStackDepth", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.MaxSyncWorkersPerSubscription != nil && 262143 < *plain.MaxSyncWorkersPerSubscription {
		return fmt.Errorf("field %s: must be <= %v", "max_sync_workers_per_subscription", 262143)
	}
	if plain.MaxWalSenders != nil && 262143 < *plain.MaxWalSenders {
		return fmt.Errorf("field %s: must be <= %v", "max_wal_senders", 262143)
	}
	if plain.MaxWalSize != nil && 2147483647 < *plain.MaxWalSize {
		return fmt.Errorf("field %s: must be <= %v", "max_wal_size", 2147483647)
	}
	if plain.MaxWalSize != nil && 2 > *plain.MaxWalSize {
		return fmt.Errorf("field %s: must be >= %v", "max_wal_size", 2)
	}
	if plain.MaxWorkerProcesses != nil && 262143 < *plain.MaxWorkerProcesses {
		return fmt.Errorf("field %s: must be <= %v", "max_worker_processes", 262143)
	}
	if plain.MinDynamicSharedMemory != nil && 2147483647 < *plain.MinDynamicSharedMemory {
		return fmt.Errorf("field %s: must be <= %v", "min_dynamic_shared_memory", 2147483647)
	}
	if plain.MinParallelIndexScanSize != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.MinParallelIndexScanSize.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MinParallelIndexScanSize", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.MinParallelTableScanSize != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.MinParallelTableScanSize.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MinParallelTableScanSize", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.MinWalSize != nil && 2147483647 < *plain.MinWalSize {
		return fmt.Errorf("field %s: must be <= %v", "min_wal_size", 2147483647)
	}
	if plain.MinWalSize != nil && 2 > *plain.MinWalSize {
		return fmt.Errorf("field %s: must be >= %v", "min_wal_size", 2)
	}
	if plain.MultixactMemberBuffers != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.MultixactMemberBuffers.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MultixactMemberBuffers", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.MultixactOffsetBuffers != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.MultixactOffsetBuffers.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MultixactOffsetBuffers", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.NotifyBuffers != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.NotifyBuffers.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "NotifyBuffers", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.ParallelSetupCost != nil && 1.79769e+308 < *plain.ParallelSetupCost {
		return fmt.Errorf("field %s: must be <= %v", "parallel_setup_cost", 1.79769e+308)
	}
	if plain.ParallelTupleCost != nil && 1.79769e+308 < *plain.ParallelTupleCost {
		return fmt.Errorf("field %s: must be <= %v", "parallel_tuple_cost", 1.79769e+308)
	}
	if v, ok := raw["password_encryption"]; !ok || v == nil {
		plain.PasswordEncryption = "{md5,scram-sha-256}"
	}
	if v, ok := raw["plan_cache_mode"]; !ok || v == nil {
		plain.PlanCacheMode = "{auto,force_generic_plan,force_custom_plan}"
	}
	if plain.Port != nil && 65535 < *plain.Port {
		return fmt.Errorf("field %s: must be <= %v", "port", 65535)
	}
	if plain.Port != nil && 1 > *plain.Port {
		return fmt.Errorf("field %s: must be >= %v", "port", 1)
	}
	if plain.RandomPageCost != nil && 1.79769e+308 < *plain.RandomPageCost {
		return fmt.Errorf("field %s: must be <= %v", "random_page_cost", 1.79769e+308)
	}
	if v, ok := raw["recovery_init_sync_method"]; !ok || v == nil {
		plain.RecoveryInitSyncMethod = "{fsync,syncfs}"
	}
	if v, ok := raw["recovery_prefetch"]; !ok || v == nil {
		plain.RecoveryPrefetch = "{off,on,try}"
	}
	if v, ok := raw["recovery_target_action"]; !ok || v == nil {
		plain.RecoveryTargetAction = "{pause,promote,shutdown}"
	}
	if plain.RecursiveWorktableFactor != nil && 1e+06 < *plain.RecursiveWorktableFactor {
		return fmt.Errorf("field %s: must be <= %v", "recursive_worktable_factor", 1e+06)
	}
	if plain.ReservedConnections != nil && 262143 < *plain.ReservedConnections {
		return fmt.Errorf("field %s: must be <= %v", "reserved_connections", 262143)
	}
	if plain.ScramIterations != nil && 2147483647 < *plain.ScramIterations {
		return fmt.Errorf("field %s: must be <= %v", "scram_iterations", 2147483647)
	}
	if plain.ScramIterations != nil && 1 > *plain.ScramIterations {
		return fmt.Errorf("field %s: must be >= %v", "scram_iterations", 1)
	}
	if plain.SeqPageCost != nil && 1.79769e+308 < *plain.SeqPageCost {
		return fmt.Errorf("field %s: must be <= %v", "seq_page_cost", 1.79769e+308)
	}
	if plain.SerializableBuffers != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.SerializableBuffers.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "SerializableBuffers", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if v, ok := raw["session_replication_role"]; !ok || v == nil {
		plain.SessionReplicationRole = "{origin,replica,local}"
	}
	if plain.SharedBuffers != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.SharedBuffers.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "SharedBuffers", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if v, ok := raw["shared_memory_type"]; !ok || v == nil {
		plain.SharedMemoryType = "{sysv,mmap}"
	}
	if v, ok := raw["ssl_max_protocol_version"]; !ok || v == nil {
		plain.SslMaxProtocolVersion = "{TLSv1,TLSv1.1,TLSv1.2,TLSv1.3}"
	}
	if v, ok := raw["ssl_min_protocol_version"]; !ok || v == nil {
		plain.SslMinProtocolVersion = "{TLSv1,TLSv1.1,TLSv1.2,TLSv1.3}"
	}
	if v, ok := raw["stats_fetch_consistency"]; !ok || v == nil {
		plain.StatsFetchConsistency = "{none,cache,snapshot}"
	}
	if plain.SubtransactionBuffers != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.SubtransactionBuffers.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "SubtransactionBuffers", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.SuperuserReservedConnections != nil && 262143 < *plain.SuperuserReservedConnections {
		return fmt.Errorf("field %s: must be <= %v", "superuser_reserved_connections", 262143)
	}
	if v, ok := raw["synchronous_commit"]; !ok || v == nil {
		plain.SynchronousCommit = "{local,remote_write,remote_apply,on,off}"
	}
	if v, ok := raw["syslog_facility"]; !ok || v == nil {
		plain.SyslogFacility = "{local0,local1,local2,local3,local4,local5,local6,local7}"
	}
	if plain.TcpKeepalivesCount != nil && 2147483647 < *plain.TcpKeepalivesCount {
		return fmt.Errorf("field %s: must be <= %v", "tcp_keepalives_count", 2147483647)
	}
	if plain.TempBuffers != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.TempBuffers.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TempBuffers", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.TempFileLimit != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.TempFileLimit.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TempFileLimit", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.TrackActivityQuerySize != nil && 1048576 < *plain.TrackActivityQuerySize {
		return fmt.Errorf("field %s: must be <= %v", "track_activity_query_size", 1048576)
	}
	if plain.TrackActivityQuerySize != nil && 100 > *plain.TrackActivityQuerySize {
		return fmt.Errorf("field %s: must be >= %v", "track_activity_query_size", 100)
	}
	if v, ok := raw["track_functions"]; !ok || v == nil {
		plain.TrackFunctions = "{none,pl,all}"
	}
	if plain.TransactionBuffers != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.TransactionBuffers.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TransactionBuffers", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if v, ok := raw["transaction_isolation"]; !ok || v == nil {
		plain.TransactionIsolation = "{serializable,repeatable read,read committed,read uncommitted}"
	}
	if plain.UnixSocketPermissions != nil && 511 < *plain.UnixSocketPermissions {
		return fmt.Errorf("field %s: must be <= %v", "unix_socket_permissions", 511)
	}
	if plain.VacuumBufferUsageLimit != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.VacuumBufferUsageLimit.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "VacuumBufferUsageLimit", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.VacuumCostLimit != nil && 10000 < *plain.VacuumCostLimit {
		return fmt.Errorf("field %s: must be <= %v", "vacuum_cost_limit", 10000)
	}
	if plain.VacuumCostLimit != nil && 1 > *plain.VacuumCostLimit {
		return fmt.Errorf("field %s: must be >= %v", "vacuum_cost_limit", 1)
	}
	if plain.VacuumCostPageDirty != nil && 10000 < *plain.VacuumCostPageDirty {
		return fmt.Errorf("field %s: must be <= %v", "vacuum_cost_page_dirty", 10000)
	}
	if plain.VacuumCostPageHit != nil && 10000 < *plain.VacuumCostPageHit {
		return fmt.Errorf("field %s: must be <= %v", "vacuum_cost_page_hit", 10000)
	}
	if plain.VacuumCostPageMiss != nil && 10000 < *plain.VacuumCostPageMiss {
		return fmt.Errorf("field %s: must be <= %v", "vacuum_cost_page_miss", 10000)
	}
	if plain.VacuumFailsafeAge != nil && 2100000000 < *plain.VacuumFailsafeAge {
		return fmt.Errorf("field %s: must be <= %v", "vacuum_failsafe_age", 2100000000)
	}
	if plain.VacuumFreezeMinAge != nil && 1000000000 < *plain.VacuumFreezeMinAge {
		return fmt.Errorf("field %s: must be <= %v", "vacuum_freeze_min_age", 1000000000)
	}
	if plain.VacuumFreezeTableAge != nil && 2000000000 < *plain.VacuumFreezeTableAge {
		return fmt.Errorf("field %s: must be <= %v", "vacuum_freeze_table_age", 2000000000)
	}
	if plain.VacuumMultixactFailsafeAge != nil && 2100000000 < *plain.VacuumMultixactFailsafeAge {
		return fmt.Errorf("field %s: must be <= %v", "vacuum_multixact_failsafe_age", 2100000000)
	}
	if plain.VacuumMultixactFreezeMinAge != nil && 1000000000 < *plain.VacuumMultixactFreezeMinAge {
		return fmt.Errorf("field %s: must be <= %v", "vacuum_multixact_freeze_min_age", 1000000000)
	}
	if plain.VacuumMultixactFreezeTableAge != nil && 2000000000 < *plain.VacuumMultixactFreezeTableAge {
		return fmt.Errorf("field %s: must be <= %v", "vacuum_multixact_freeze_table_age", 2000000000)
	}
	if plain.WalBuffers != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.WalBuffers.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "WalBuffers", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if v, ok := raw["wal_compression"]; !ok || v == nil {
		plain.WalCompression = "{pglz,lz4,zstd,on,off}"
	}
	if plain.WalDecodeBufferSize != nil && 1073741823 < *plain.WalDecodeBufferSize {
		return fmt.Errorf("field %s: must be <= %v", "wal_decode_buffer_size", 1073741823)
	}
	if plain.WalDecodeBufferSize != nil && 65536 > *plain.WalDecodeBufferSize {
		return fmt.Errorf("field %s: must be >= %v", "wal_decode_buffer_size", 65536)
	}
	if plain.WalKeepSize != nil && 2147483647 < *plain.WalKeepSize {
		return fmt.Errorf("field %s: must be <= %v", "wal_keep_size", 2147483647)
	}
	if v, ok := raw["wal_level"]; !ok || v == nil {
		plain.WalLevel = "{minimal,replica,logical}"
	}
	if plain.WalSkipThreshold != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.WalSkipThreshold.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "WalSkipThreshold", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if v, ok := raw["wal_sync_method"]; !ok || v == nil {
		plain.WalSyncMethod = "{fsync,fdatasync,open_sync,open_datasync}"
	}
	if plain.WalWriterFlushAfter != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.WalWriterFlushAfter.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "WalWriterFlushAfter", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if plain.WorkMem != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, plain.WorkMem.String()); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "WorkMem", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if v, ok := raw["xmlbinary"]; !ok || v == nil {
		plain.Xmlbinary = "{base64,hex}"
	}
	if v, ok := raw["xmloption"]; !ok || v == nil {
		plain.Xmloption = "{content,document}"
	}
	*j = PostgresConf(plain)
	return nil
}

// PostgREST API server configuration
type PostgrestConf struct {
	// Database role with admin privileges
	AdminRole string `json:"admin_role,omitempty" yaml:"admin_role,omitempty" mapstructure:"admin_role,omitempty"`

	// Database role for anonymous access
	AnonymousRole string `json:"anonymous_role,omitempty" yaml:"anonymous_role,omitempty" mapstructure:"anonymous_role,omitempty"`

	// Database connection pool size
	DbPool int `json:"db_pool,omitempty" yaml:"db_pool,omitempty" mapstructure:"db_pool,omitempty"`

	// Database connection pool timeout in seconds
	DbPoolTimeout int `json:"db_pool_timeout,omitempty" yaml:"db_pool_timeout,omitempty" mapstructure:"db_pool_timeout,omitempty"`

	// Database schemas to expose via API
	DbSchemas string `json:"db_schemas,omitempty" yaml:"db_schemas,omitempty" mapstructure:"db_schemas,omitempty"`

	// Database connection URI
	DbUri *string `json:"db_uri,omitempty" yaml:"db_uri,omitempty" mapstructure:"db_uri,omitempty"`

	// JWT audience claim
	JwtAud string `json:"jwt_aud,omitempty" yaml:"jwt_aud,omitempty" mapstructure:"jwt_aud,omitempty"`

	// JWT secret for authentication
	JwtSecret *string `json:"jwt_secret,omitempty" yaml:"jwt_secret,omitempty" mapstructure:"jwt_secret,omitempty"`

	// Whether JWT secret is base64 encoded
	JwtSecretIsBase64 bool `json:"jwt_secret_is_base64,omitempty" yaml:"jwt_secret_is_base64,omitempty" mapstructure:"jwt_secret_is_base64,omitempty"`

	// Logging level
	LogLevel PostgrestConfLogLevel `json:"log_level,omitempty" yaml:"log_level,omitempty" mapstructure:"log_level,omitempty"`

	// Maximum rows returned in a single response
	MaxRows *int `json:"max_rows,omitempty" yaml:"max_rows,omitempty" mapstructure:"max_rows,omitempty"`

	// Pre-request function to call
	PreRequest string `json:"pre_request,omitempty" yaml:"pre_request,omitempty" mapstructure:"pre_request,omitempty"`

	// JWT claim key for role
	RoleClaimKey string `json:"role_claim_key,omitempty" yaml:"role_claim_key,omitempty" mapstructure:"role_claim_key,omitempty"`

	// Server host address
	ServerHost string `json:"server_host,omitempty" yaml:"server_host,omitempty" mapstructure:"server_host,omitempty"`

	// Server port
	ServerPort int `json:"server_port,omitempty" yaml:"server_port,omitempty" mapstructure:"server_port,omitempty"`

	// Path to SSL certificate file
	ServerSslCert string `json:"server_ssl_cert,omitempty" yaml:"server_ssl_cert,omitempty" mapstructure:"server_ssl_cert,omitempty"`

	// Path to SSL private key file
	ServerSslKey string `json:"server_ssl_key,omitempty" yaml:"server_ssl_key,omitempty" mapstructure:"server_ssl_key,omitempty"`
}

type PostgrestConfLogLevel string

const PostgrestConfLogLevelCrit PostgrestConfLogLevel = "crit"
const PostgrestConfLogLevelDebug PostgrestConfLogLevel = "debug"
const PostgrestConfLogLevelError PostgrestConfLogLevel = "error"
const PostgrestConfLogLevelInfo PostgrestConfLogLevel = "info"
const PostgrestConfLogLevelWarn PostgrestConfLogLevel = "warn"

var enumValues_PostgrestConfLogLevel = []interface{}{
	"crit",
	"error",
	"warn",
	"info",
	"debug",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PostgrestConfLogLevel) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PostgrestConfLogLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PostgrestConfLogLevel, v)
	}
	*j = PostgrestConfLogLevel(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PostgrestConf) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain PostgrestConf
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["admin_role"]; !ok || v == nil {
		plain.AdminRole = "postgres"
	}
	if v, ok := raw["anonymous_role"]; !ok || v == nil {
		plain.AnonymousRole = "anon"
	}
	if v, ok := raw["db_pool"]; !ok || v == nil {
		plain.DbPool = 10.0
	}
	if 1000 < plain.DbPool {
		return fmt.Errorf("field %s: must be <= %v", "db_pool", 1000)
	}
	if 1 > plain.DbPool {
		return fmt.Errorf("field %s: must be >= %v", "db_pool", 1)
	}
	if v, ok := raw["db_pool_timeout"]; !ok || v == nil {
		plain.DbPoolTimeout = 10.0
	}
	if 1 > plain.DbPoolTimeout {
		return fmt.Errorf("field %s: must be >= %v", "db_pool_timeout", 1)
	}
	if v, ok := raw["db_schemas"]; !ok || v == nil {
		plain.DbSchemas = "public"
	}
	if plain.DbUri != nil {
		if matched, _ := regexp.MatchString(`^postgres(ql)?://.*`, string(*plain.DbUri)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DbUri", `^postgres(ql)?://.*`)
		}
	}
	if v, ok := raw["jwt_aud"]; !ok || v == nil {
		plain.JwtAud = ""
	}
	if v, ok := raw["jwt_secret_is_base64"]; !ok || v == nil {
		plain.JwtSecretIsBase64 = false
	}
	if v, ok := raw["log_level"]; !ok || v == nil {
		plain.LogLevel = "error"
	}
	if plain.MaxRows != nil && 1 > *plain.MaxRows {
		return fmt.Errorf("field %s: must be >= %v", "max_rows", 1)
	}
	if v, ok := raw["pre_request"]; !ok || v == nil {
		plain.PreRequest = ""
	}
	if v, ok := raw["role_claim_key"]; !ok || v == nil {
		plain.RoleClaimKey = "role"
	}
	if v, ok := raw["server_host"]; !ok || v == nil {
		plain.ServerHost = "0.0.0.0"
	}
	if v, ok := raw["server_port"]; !ok || v == nil {
		plain.ServerPort = 3000.0
	}
	if 65535 < plain.ServerPort {
		return fmt.Errorf("field %s: must be <= %v", "server_port", 65535)
	}
	if 1 > plain.ServerPort {
		return fmt.Errorf("field %s: must be >= %v", "server_port", 1)
	}
	if v, ok := raw["server_ssl_cert"]; !ok || v == nil {
		plain.ServerSslCert = ""
	}
	if v, ok := raw["server_ssl_key"]; !ok || v == nil {
		plain.ServerSslKey = ""
	}
	*j = PostgrestConf(plain)
	return nil
}

// WAL-G backup and archiving configuration
type WalgConf struct {
	// Azure storage account key
	AzAccountKey *string `json:"az_account_key,omitempty" yaml:"az_account_key,omitempty" mapstructure:"az_account_key,omitempty"`

	// Azure storage account name
	AzAccountName *string `json:"az_account_name,omitempty" yaml:"az_account_name,omitempty" mapstructure:"az_account_name,omitempty"`

	// Azure Storage prefix
	AzPrefix *string `json:"az_prefix,omitempty" yaml:"az_prefix,omitempty" mapstructure:"az_prefix,omitempty"`

	// Number of backups to retain
	BackupRetainCount int `json:"backup_retain_count,omitempty" yaml:"backup_retain_count,omitempty" mapstructure:"backup_retain_count,omitempty"`

	// Backup schedule in cron format
	BackupSchedule string `json:"backup_schedule,omitempty" yaml:"backup_schedule,omitempty" mapstructure:"backup_schedule,omitempty"`

	// Compression level (0-9)
	CompressionLevel int `json:"compression_level,omitempty" yaml:"compression_level,omitempty" mapstructure:"compression_level,omitempty"`

	// Compression method for backups
	CompressionMethod WalgConfCompressionMethod `json:"compression_method,omitempty" yaml:"compression_method,omitempty" mapstructure:"compression_method,omitempty"`

	// Maximum steps for delta backups
	DeltaMaxSteps int `json:"delta_max_steps,omitempty" yaml:"delta_max_steps,omitempty" mapstructure:"delta_max_steps,omitempty"`

	// Enable or disable WAL-G
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Local file system prefix for backups
	FilePrefix *string `json:"file_prefix,omitempty" yaml:"file_prefix,omitempty" mapstructure:"file_prefix,omitempty"`

	// Google Cloud Storage prefix (e.g., gs://bucket/path/to/folder)
	GsPrefix *string `json:"gs_prefix,omitempty" yaml:"gs_prefix,omitempty" mapstructure:"gs_prefix,omitempty"`

	// Google Cloud project ID
	GsProjectId *string `json:"gs_project_id,omitempty" yaml:"gs_project_id,omitempty" mapstructure:"gs_project_id,omitempty"`

	// Google Cloud service account key JSON
	GsServiceAccountKey *string `json:"gs_service_account_key,omitempty" yaml:"gs_service_account_key,omitempty" mapstructure:"gs_service_account_key,omitempty"`

	// PostgreSQL data directory path
	PostgresqlDataDir string `json:"postgresql_data_dir,omitempty" yaml:"postgresql_data_dir,omitempty" mapstructure:"postgresql_data_dir,omitempty"`

	// AWS S3 access key ID
	S3AccessKey *string `json:"s3_access_key,omitempty" yaml:"s3_access_key,omitempty" mapstructure:"s3_access_key,omitempty"`

	// Custom S3 endpoint URL
	S3Endpoint *string `json:"s3_endpoint,omitempty" yaml:"s3_endpoint,omitempty" mapstructure:"s3_endpoint,omitempty"`

	// S3 storage prefix (e.g., s3://bucket/path/to/folder)
	S3Prefix *string `json:"s3_prefix,omitempty" yaml:"s3_prefix,omitempty" mapstructure:"s3_prefix,omitempty"`

	// AWS S3 region
	S3Region string `json:"s3_region,omitempty" yaml:"s3_region,omitempty" mapstructure:"s3_region,omitempty"`

	// AWS S3 secret access key
	S3SecretKey *string `json:"s3_secret_key,omitempty" yaml:"s3_secret_key,omitempty" mapstructure:"s3_secret_key,omitempty"`

	// AWS S3 session token (for temporary credentials)
	S3SessionToken *string `json:"s3_session_token,omitempty" yaml:"s3_session_token,omitempty" mapstructure:"s3_session_token,omitempty"`

	// Use SSL for S3 connections
	S3UseSsl bool `json:"s3_use_ssl,omitempty" yaml:"s3_use_ssl,omitempty" mapstructure:"s3_use_ssl,omitempty"`

	// Command to create WAL stream
	StreamCreateCommand *string `json:"stream_create_command,omitempty" yaml:"stream_create_command,omitempty" mapstructure:"stream_create_command,omitempty"`

	// Command to restore from WAL stream
	StreamRestoreCommand *string `json:"stream_restore_command,omitempty" yaml:"stream_restore_command,omitempty" mapstructure:"stream_restore_command,omitempty"`

	// Number of concurrent uploads
	UploadConcurrency int `json:"upload_concurrency,omitempty" yaml:"upload_concurrency,omitempty" mapstructure:"upload_concurrency,omitempty"`

	// Number of concurrent disk operations
	UploadDiskConcurrency int `json:"upload_disk_concurrency,omitempty" yaml:"upload_disk_concurrency,omitempty" mapstructure:"upload_disk_concurrency,omitempty"`

	// Verify WAL checksums during backup
	WalVerifyChecksum bool `json:"wal_verify_checksum,omitempty" yaml:"wal_verify_checksum,omitempty" mapstructure:"wal_verify_checksum,omitempty"`
}

type WalgConfCompressionMethod string

const WalgConfCompressionMethodBrotli WalgConfCompressionMethod = "brotli"
const WalgConfCompressionMethodLz4 WalgConfCompressionMethod = "lz4"
const WalgConfCompressionMethodLzma WalgConfCompressionMethod = "lzma"
const WalgConfCompressionMethodZstd WalgConfCompressionMethod = "zstd"

var enumValues_WalgConfCompressionMethod = []interface{}{
	"lz4",
	"lzma",
	"brotli",
	"zstd",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WalgConfCompressionMethod) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WalgConfCompressionMethod {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WalgConfCompressionMethod, v)
	}
	*j = WalgConfCompressionMethod(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WalgConf) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain WalgConf
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["backup_retain_count"]; !ok || v == nil {
		plain.BackupRetainCount = 7.0
	}
	if 1 > plain.BackupRetainCount {
		return fmt.Errorf("field %s: must be >= %v", "backup_retain_count", 1)
	}
	if v, ok := raw["backup_schedule"]; !ok || v == nil {
		plain.BackupSchedule = "0 2 * * *"
	}
	if v, ok := raw["compression_level"]; !ok || v == nil {
		plain.CompressionLevel = 1.0
	}
	if 9 < plain.CompressionLevel {
		return fmt.Errorf("field %s: must be <= %v", "compression_level", 9)
	}
	if 0 > plain.CompressionLevel {
		return fmt.Errorf("field %s: must be >= %v", "compression_level", 0)
	}
	if v, ok := raw["compression_method"]; !ok || v == nil {
		plain.CompressionMethod = "lz4"
	}
	if v, ok := raw["delta_max_steps"]; !ok || v == nil {
		plain.DeltaMaxSteps = 32.0
	}
	if 1 > plain.DeltaMaxSteps {
		return fmt.Errorf("field %s: must be >= %v", "delta_max_steps", 1)
	}
	if v, ok := raw["enabled"]; !ok || v == nil {
		plain.Enabled = false
	}
	if plain.GsPrefix != nil {
		if matched, _ := regexp.MatchString(`^gs://.*`, string(*plain.GsPrefix)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "GsPrefix", `^gs://.*`)
		}
	}
	if v, ok := raw["postgresql_data_dir"]; !ok || v == nil {
		plain.PostgresqlDataDir = "/var/lib/postgresql/data"
	}
	if plain.S3Prefix != nil {
		if matched, _ := regexp.MatchString(`^s3://.*`, string(*plain.S3Prefix)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "S3Prefix", `^s3://.*`)
		}
	}
	if v, ok := raw["s3_region"]; !ok || v == nil {
		plain.S3Region = "us-east-1"
	}
	if v, ok := raw["s3_use_ssl"]; !ok || v == nil {
		plain.S3UseSsl = true
	}
	if v, ok := raw["upload_concurrency"]; !ok || v == nil {
		plain.UploadConcurrency = 16.0
	}
	if 100 < plain.UploadConcurrency {
		return fmt.Errorf("field %s: must be <= %v", "upload_concurrency", 100)
	}
	if 1 > plain.UploadConcurrency {
		return fmt.Errorf("field %s: must be >= %v", "upload_concurrency", 1)
	}
	if v, ok := raw["upload_disk_concurrency"]; !ok || v == nil {
		plain.UploadDiskConcurrency = 1.0
	}
	if 100 < plain.UploadDiskConcurrency {
		return fmt.Errorf("field %s: must be <= %v", "upload_disk_concurrency", 100)
	}
	if 1 > plain.UploadDiskConcurrency {
		return fmt.Errorf("field %s: must be >= %v", "upload_disk_concurrency", 1)
	}
	if v, ok := raw["wal_verify_checksum"]; !ok || v == nil {
		plain.WalVerifyChecksum = true
	}
	*j = WalgConf(plain)
	return nil
}
