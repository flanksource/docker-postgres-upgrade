// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package pkg

import (
	"encoding/json"
	"github.com/flanksource/postgres/pkg/types"
)
import "fmt"
import "reflect"
import "regexp"

// Database connection configuration for PgBouncer
type DatabaseConfig struct {
	// Query to run on new connections
	ConnectQuery *string `json:"connect_query,omitempty" yaml:"connect_query,omitempty" mapstructure:"connect_query,omitempty"`

	// Database name
	Dbname *string `json:"dbname,omitempty" yaml:"dbname,omitempty" mapstructure:"dbname,omitempty"`

	// Database host
	Host string `json:"host,omitempty" yaml:"host,omitempty" mapstructure:"host,omitempty"`

	// Database password
	Password *string `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`

	// Pool size for this database
	PoolSize *int `json:"pool_size,omitempty" yaml:"pool_size,omitempty" mapstructure:"pool_size,omitempty"`

	// Database port
	Port int `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`

	// Database user
	User *string `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DatabaseConfig) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain DatabaseConfig
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["host"]; !ok || v == nil {
		plain.Host = "localhost"
	}
	if plain.PoolSize != nil && 1 > *plain.PoolSize {
		return fmt.Errorf("field %s: must be >= %v", "pool_size", 1)
	}
	if v, ok := raw["port"]; !ok || v == nil {
		plain.Port = 5432.0
	}
	if 65535 < plain.Port {
		return fmt.Errorf("field %s: must be <= %v", "port", 65535)
	}
	if 1 > plain.Port {
		return fmt.Errorf("field %s: must be >= %v", "port", 1)
	}
	*j = DatabaseConfig(plain)
	return nil
}

// PGAudit extension configuration for PostgreSQL audit logging
type PGAuditConf struct {
	// Specifies whether audit logging should be filtered using role-based access
	// control
	FilterUsingRole PGAuditConfFilterUsingRole `json:"filter_using_role,omitempty" yaml:"filter_using_role,omitempty" mapstructure:"filter_using_role,omitempty"`

	// Specifies which classes of statements will be logged by session audit logging
	Log PGAuditConfLog `json:"log,omitempty" yaml:"log,omitempty" mapstructure:"log,omitempty"`

	// Specifies that session logging should be enabled in the case where all
	// relations in a statement are in pg_catalog
	LogCatalog PGAuditConfLogCatalog `json:"log_catalog,omitempty" yaml:"log_catalog,omitempty" mapstructure:"log_catalog,omitempty"`

	// Specifies whether log messages will be visible to a client process
	LogClient PGAuditConfLogClient `json:"log_client,omitempty" yaml:"log_client,omitempty" mapstructure:"log_client,omitempty"`

	// Specifies the log level that will be used for log entries
	LogLevel PGAuditConfLogLevel `json:"log_level,omitempty" yaml:"log_level,omitempty" mapstructure:"log_level,omitempty"`

	// Specifies that audit logging should include the parameters that were passed
	// with the statement
	LogParameter PGAuditConfLogParameter `json:"log_parameter,omitempty" yaml:"log_parameter,omitempty" mapstructure:"log_parameter,omitempty"`

	// Sets the maximum size of a parameter value that will be logged
	LogParameterMaxSize string `json:"log_parameter_max_size,omitempty" yaml:"log_parameter_max_size,omitempty" mapstructure:"log_parameter_max_size,omitempty"`

	// Specifies whether session audit logging should create a separate log entry for
	// each relation referenced in a SELECT or DML statement
	LogRelation PGAuditConfLogRelation `json:"log_relation,omitempty" yaml:"log_relation,omitempty" mapstructure:"log_relation,omitempty"`

	// Specifies whether logging will include the statement text and parameters (if
	// enabled)
	LogStatement PGAuditConfLogStatement `json:"log_statement,omitempty" yaml:"log_statement,omitempty" mapstructure:"log_statement,omitempty"`

	// Specifies whether logging will include the statement text and parameters (if
	// enabled) with the first log entry for a statement/substatement combination or
	// with every log entry
	LogStatementOnce PGAuditConfLogStatementOnce `json:"log_statement_once,omitempty" yaml:"log_statement_once,omitempty" mapstructure:"log_statement_once,omitempty"`

	// Sets the maximum stack depth for audit logging to prevent infinite recursion
	MaxStackDepth *string `json:"max_stack_depth,omitempty" yaml:"max_stack_depth,omitempty" mapstructure:"max_stack_depth,omitempty"`

	// Specifies which classes of statements will be logged by object audit logging
	ObjectLog PGAuditConfObjectLog `json:"object_log,omitempty" yaml:"object_log,omitempty" mapstructure:"object_log,omitempty"`

	// Specifies that object logging should be enabled in the case where all relations
	// in a statement are in pg_catalog
	ObjectLogCatalog PGAuditConfObjectLogCatalog `json:"object_log_catalog,omitempty" yaml:"object_log_catalog,omitempty" mapstructure:"object_log_catalog,omitempty"`

	// Specifies the master role to use for object audit logging
	Role *string `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`

	// Specifies whether the statement name, if provided, should be included in the
	// session log
	SessionLogStatementName PGAuditConfSessionLogStatementName `json:"session_log_statement_name,omitempty" yaml:"session_log_statement_name,omitempty" mapstructure:"session_log_statement_name,omitempty"`
}

type PGAuditConfFilterUsingRole string

const PGAuditConfFilterUsingRoleOff PGAuditConfFilterUsingRole = "off"
const PGAuditConfFilterUsingRoleOn PGAuditConfFilterUsingRole = "on"

var enumValues_PGAuditConfFilterUsingRole = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfFilterUsingRole) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfFilterUsingRole {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfFilterUsingRole, v)
	}
	*j = PGAuditConfFilterUsingRole(v)
	return nil
}

type PGAuditConfLog string

const PGAuditConfLogAll PGAuditConfLog = "all"

type PGAuditConfLogCatalog string

const PGAuditConfLogCatalogOff PGAuditConfLogCatalog = "off"
const PGAuditConfLogCatalogOn PGAuditConfLogCatalog = "on"

var enumValues_PGAuditConfLogCatalog = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLogCatalog) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLogCatalog {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLogCatalog, v)
	}
	*j = PGAuditConfLogCatalog(v)
	return nil
}

type PGAuditConfLogClient string

const PGAuditConfLogClientOff PGAuditConfLogClient = "off"
const PGAuditConfLogClientOn PGAuditConfLogClient = "on"

var enumValues_PGAuditConfLogClient = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLogClient) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLogClient {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLogClient, v)
	}
	*j = PGAuditConfLogClient(v)
	return nil
}

const PGAuditConfLogDdl PGAuditConfLog = "ddl"
const PGAuditConfLogFunction PGAuditConfLog = "function"

type PGAuditConfLogLevel string

const PGAuditConfLogLevelDebug1 PGAuditConfLogLevel = "debug1"
const PGAuditConfLogLevelDebug2 PGAuditConfLogLevel = "debug2"
const PGAuditConfLogLevelDebug3 PGAuditConfLogLevel = "debug3"
const PGAuditConfLogLevelDebug4 PGAuditConfLogLevel = "debug4"
const PGAuditConfLogLevelDebug5 PGAuditConfLogLevel = "debug5"
const PGAuditConfLogLevelInfo PGAuditConfLogLevel = "info"
const PGAuditConfLogLevelLog PGAuditConfLogLevel = "log"
const PGAuditConfLogLevelNotice PGAuditConfLogLevel = "notice"
const PGAuditConfLogLevelWarning PGAuditConfLogLevel = "warning"

var enumValues_PGAuditConfLogLevel = []interface{}{
	"debug5",
	"debug4",
	"debug3",
	"debug2",
	"debug1",
	"info",
	"notice",
	"warning",
	"log",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLogLevel) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLogLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLogLevel, v)
	}
	*j = PGAuditConfLogLevel(v)
	return nil
}

const PGAuditConfLogMisc PGAuditConfLog = "misc"
const PGAuditConfLogMiscSet PGAuditConfLog = "misc_set"
const PGAuditConfLogNone PGAuditConfLog = "none"

type PGAuditConfLogParameter string

const PGAuditConfLogParameterOff PGAuditConfLogParameter = "off"
const PGAuditConfLogParameterOn PGAuditConfLogParameter = "on"

var enumValues_PGAuditConfLogParameter = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLogParameter) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLogParameter {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLogParameter, v)
	}
	*j = PGAuditConfLogParameter(v)
	return nil
}

const PGAuditConfLogRead PGAuditConfLog = "read"

type PGAuditConfLogRelation string

const PGAuditConfLogRelationOff PGAuditConfLogRelation = "off"
const PGAuditConfLogRelationOn PGAuditConfLogRelation = "on"

var enumValues_PGAuditConfLogRelation = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLogRelation) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLogRelation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLogRelation, v)
	}
	*j = PGAuditConfLogRelation(v)
	return nil
}

const PGAuditConfLogRole PGAuditConfLog = "role"

type PGAuditConfLogStatement string

const PGAuditConfLogStatementOff PGAuditConfLogStatement = "off"
const PGAuditConfLogStatementOn PGAuditConfLogStatement = "on"

type PGAuditConfLogStatementOnce string

const PGAuditConfLogStatementOnceOff PGAuditConfLogStatementOnce = "off"
const PGAuditConfLogStatementOnceOn PGAuditConfLogStatementOnce = "on"

var enumValues_PGAuditConfLogStatementOnce = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLogStatementOnce) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLogStatementOnce {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLogStatementOnce, v)
	}
	*j = PGAuditConfLogStatementOnce(v)
	return nil
}

var enumValues_PGAuditConfLogStatement = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLogStatement) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLogStatement {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLogStatement, v)
	}
	*j = PGAuditConfLogStatement(v)
	return nil
}

const PGAuditConfLogWrite PGAuditConfLog = "write"

var enumValues_PGAuditConfLog = []interface{}{
	"none",
	"read",
	"write",
	"function",
	"role",
	"ddl",
	"misc",
	"misc_set",
	"all",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfLog) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfLog {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfLog, v)
	}
	*j = PGAuditConfLog(v)
	return nil
}

type PGAuditConfObjectLog string

const PGAuditConfObjectLogAll PGAuditConfObjectLog = "all"

type PGAuditConfObjectLogCatalog string

const PGAuditConfObjectLogCatalogOff PGAuditConfObjectLogCatalog = "off"
const PGAuditConfObjectLogCatalogOn PGAuditConfObjectLogCatalog = "on"

var enumValues_PGAuditConfObjectLogCatalog = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfObjectLogCatalog) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfObjectLogCatalog {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfObjectLogCatalog, v)
	}
	*j = PGAuditConfObjectLogCatalog(v)
	return nil
}

const PGAuditConfObjectLogDdl PGAuditConfObjectLog = "ddl"
const PGAuditConfObjectLogFunction PGAuditConfObjectLog = "function"
const PGAuditConfObjectLogMisc PGAuditConfObjectLog = "misc"
const PGAuditConfObjectLogMiscSet PGAuditConfObjectLog = "misc_set"
const PGAuditConfObjectLogNone PGAuditConfObjectLog = "none"
const PGAuditConfObjectLogRead PGAuditConfObjectLog = "read"
const PGAuditConfObjectLogRole PGAuditConfObjectLog = "role"
const PGAuditConfObjectLogWrite PGAuditConfObjectLog = "write"

var enumValues_PGAuditConfObjectLog = []interface{}{
	"none",
	"read",
	"write",
	"function",
	"role",
	"ddl",
	"misc",
	"misc_set",
	"all",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfObjectLog) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfObjectLog {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfObjectLog, v)
	}
	*j = PGAuditConfObjectLog(v)
	return nil
}

type PGAuditConfSessionLogStatementName string

const PGAuditConfSessionLogStatementNameOff PGAuditConfSessionLogStatementName = "off"
const PGAuditConfSessionLogStatementNameOn PGAuditConfSessionLogStatementName = "on"

var enumValues_PGAuditConfSessionLogStatementName = []interface{}{
	"on",
	"off",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConfSessionLogStatementName) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PGAuditConfSessionLogStatementName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PGAuditConfSessionLogStatementName, v)
	}
	*j = PGAuditConfSessionLogStatementName(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PGAuditConf) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain PGAuditConf
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["filter_using_role"]; !ok || v == nil {
		plain.FilterUsingRole = "off"
	}
	if v, ok := raw["log"]; !ok || v == nil {
		plain.Log = "none"
	}
	if v, ok := raw["log_catalog"]; !ok || v == nil {
		plain.LogCatalog = "on"
	}
	if v, ok := raw["log_client"]; !ok || v == nil {
		plain.LogClient = "off"
	}
	if v, ok := raw["log_level"]; !ok || v == nil {
		plain.LogLevel = "log"
	}
	if v, ok := raw["log_parameter"]; !ok || v == nil {
		plain.LogParameter = "off"
	}
	if v, ok := raw["log_parameter_max_size"]; !ok || v == nil {
		plain.LogParameterMaxSize = "0"
	}
	if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, string(plain.LogParameterMaxSize)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "LogParameterMaxSize", `^[0-9]+[kMGT]?B?$`)
	}
	if v, ok := raw["log_relation"]; !ok || v == nil {
		plain.LogRelation = "off"
	}
	if v, ok := raw["log_statement"]; !ok || v == nil {
		plain.LogStatement = "on"
	}
	if v, ok := raw["log_statement_once"]; !ok || v == nil {
		plain.LogStatementOnce = "off"
	}
	if plain.MaxStackDepth != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, string(*plain.MaxStackDepth)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MaxStackDepth", `^[0-9]+[kMGT]?B?$`)
		}
	}
	if v, ok := raw["object_log"]; !ok || v == nil {
		plain.ObjectLog = "none"
	}
	if v, ok := raw["object_log_catalog"]; !ok || v == nil {
		plain.ObjectLogCatalog = "on"
	}
	if v, ok := raw["session_log_statement_name"]; !ok || v == nil {
		plain.SessionLogStatementName = "off"
	}
	*j = PGAuditConf(plain)
	return nil
}

// PgBouncer connection pooler configuration
type PgBouncerConf struct {
	// Administrative password for PgBouncer
	AdminPassword *string `json:"admin_password,omitempty" yaml:"admin_password,omitempty" mapstructure:"admin_password,omitempty"`

	// Administrative user for PgBouncer
	AdminUser *string `json:"admin_user,omitempty" yaml:"admin_user,omitempty" mapstructure:"admin_user,omitempty"`

	// Path to authentication file
	AuthFile string `json:"auth_file,omitempty" yaml:"auth_file,omitempty" mapstructure:"auth_file,omitempty"`

	// Query to authenticate users
	AuthQuery string `json:"auth_query,omitempty" yaml:"auth_query,omitempty" mapstructure:"auth_query,omitempty"`

	// Authentication type for PgBouncer
	AuthType PgBouncerConfAuthType `json:"auth_type,omitempty" yaml:"auth_type,omitempty" mapstructure:"auth_type,omitempty"`

	// Maximum idle time for client connections
	ClientIdleTimeout string `json:"client_idle_timeout,omitempty" yaml:"client_idle_timeout,omitempty" mapstructure:"client_idle_timeout,omitempty"`

	// Database connection configurations
	Databases map[string]DatabaseConfig `json:"databases,omitempty" yaml:"databases,omitempty" mapstructure:"databases,omitempty"`

	// Default pool size for databases
	DefaultPoolSize int `json:"default_pool_size,omitempty" yaml:"default_pool_size,omitempty" mapstructure:"default_pool_size,omitempty"`

	// Specifies the address to listen on
	ListenAddress string `json:"listen_address,omitempty" yaml:"listen_address,omitempty" mapstructure:"listen_address,omitempty"`

	// Specifies the port to listen on
	ListenPort int `json:"listen_port,omitempty" yaml:"listen_port,omitempty" mapstructure:"listen_port,omitempty"`

	// Maximum number of client connections allowed
	MaxClientConn int `json:"max_client_conn,omitempty" yaml:"max_client_conn,omitempty" mapstructure:"max_client_conn,omitempty"`

	// Minimum pool size
	MinPoolSize int `json:"min_pool_size,omitempty" yaml:"min_pool_size,omitempty" mapstructure:"min_pool_size,omitempty"`

	// Pooling mode to use
	PoolMode PgBouncerConfPoolMode `json:"pool_mode,omitempty" yaml:"pool_mode,omitempty" mapstructure:"pool_mode,omitempty"`

	// Query timeout
	QueryTimeout string `json:"query_timeout,omitempty" yaml:"query_timeout,omitempty" mapstructure:"query_timeout,omitempty"`

	// Reserved pool size
	ReservePoolSize *int `json:"reserve_pool_size,omitempty" yaml:"reserve_pool_size,omitempty" mapstructure:"reserve_pool_size,omitempty"`

	// Maximum idle time for server connections
	ServerIdleTimeout string `json:"server_idle_timeout,omitempty" yaml:"server_idle_timeout,omitempty" mapstructure:"server_idle_timeout,omitempty"`

	// Maximum lifetime of a server connection
	ServerLifetime string `json:"server_lifetime,omitempty" yaml:"server_lifetime,omitempty" mapstructure:"server_lifetime,omitempty"`

	// Query to run on server connection before returning to pool
	ServerResetQuery string `json:"server_reset_query,omitempty" yaml:"server_reset_query,omitempty" mapstructure:"server_reset_query,omitempty"`
}

type PgBouncerConfAuthType string

const PgBouncerConfAuthTypeAny PgBouncerConfAuthType = "any"
const PgBouncerConfAuthTypeCert PgBouncerConfAuthType = "cert"
const PgBouncerConfAuthTypeHba PgBouncerConfAuthType = "hba"
const PgBouncerConfAuthTypeMd5 PgBouncerConfAuthType = "md5"
const PgBouncerConfAuthTypePam PgBouncerConfAuthType = "pam"
const PgBouncerConfAuthTypePlain PgBouncerConfAuthType = "plain"
const PgBouncerConfAuthTypeScramSha256 PgBouncerConfAuthType = "scram-sha-256"
const PgBouncerConfAuthTypeTrust PgBouncerConfAuthType = "trust"

var enumValues_PgBouncerConfAuthType = []interface{}{
	"any",
	"trust",
	"plain",
	"md5",
	"scram-sha-256",
	"cert",
	"hba",
	"pam",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PgBouncerConfAuthType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PgBouncerConfAuthType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PgBouncerConfAuthType, v)
	}
	*j = PgBouncerConfAuthType(v)
	return nil
}

type PgBouncerConfPoolMode string

const PgBouncerConfPoolModeSession PgBouncerConfPoolMode = "session"
const PgBouncerConfPoolModeStatement PgBouncerConfPoolMode = "statement"
const PgBouncerConfPoolModeTransaction PgBouncerConfPoolMode = "transaction"

var enumValues_PgBouncerConfPoolMode = []interface{}{
	"session",
	"transaction",
	"statement",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PgBouncerConfPoolMode) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PgBouncerConfPoolMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PgBouncerConfPoolMode, v)
	}
	*j = PgBouncerConfPoolMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PgBouncerConf) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain PgBouncerConf
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["auth_file"]; !ok || v == nil {
		plain.AuthFile = "userlist.txt"
	}
	if v, ok := raw["auth_query"]; !ok || v == nil {
		plain.AuthQuery = "SELECT usename, passwd FROM pg_shadow WHERE usename=$1"
	}
	if v, ok := raw["auth_type"]; !ok || v == nil {
		plain.AuthType = "md5"
	}
	if v, ok := raw["client_idle_timeout"]; !ok || v == nil {
		plain.ClientIdleTimeout = "0"
	}
	if matched, _ := regexp.MatchString(`^[0-9]+(us|ms|s|min|h|d)?$`, string(plain.ClientIdleTimeout)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "ClientIdleTimeout", `^[0-9]+(us|ms|s|min|h|d)?$`)
	}
	if v, ok := raw["default_pool_size"]; !ok || v == nil {
		plain.DefaultPoolSize = 25.0
	}
	if 1 > plain.DefaultPoolSize {
		return fmt.Errorf("field %s: must be >= %v", "default_pool_size", 1)
	}
	if v, ok := raw["listen_address"]; !ok || v == nil {
		plain.ListenAddress = "0.0.0.0"
	}
	if v, ok := raw["listen_port"]; !ok || v == nil {
		plain.ListenPort = 6432.0
	}
	if 65535 < plain.ListenPort {
		return fmt.Errorf("field %s: must be <= %v", "listen_port", 65535)
	}
	if 1 > plain.ListenPort {
		return fmt.Errorf("field %s: must be >= %v", "listen_port", 1)
	}
	if v, ok := raw["max_client_conn"]; !ok || v == nil {
		plain.MaxClientConn = 100.0
	}
	if 1 > plain.MaxClientConn {
		return fmt.Errorf("field %s: must be >= %v", "max_client_conn", 1)
	}
	if v, ok := raw["min_pool_size"]; !ok || v == nil {
		plain.MinPoolSize = 0.0
	}
	if 0 > plain.MinPoolSize {
		return fmt.Errorf("field %s: must be >= %v", "min_pool_size", 0)
	}
	if v, ok := raw["pool_mode"]; !ok || v == nil {
		plain.PoolMode = "transaction"
	}
	if v, ok := raw["query_timeout"]; !ok || v == nil {
		plain.QueryTimeout = "0"
	}
	if matched, _ := regexp.MatchString(`^[0-9]+(us|ms|s|min|h|d)?$`, string(plain.QueryTimeout)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "QueryTimeout", `^[0-9]+(us|ms|s|min|h|d)?$`)
	}
	if plain.ReservePoolSize != nil && 0 > *plain.ReservePoolSize {
		return fmt.Errorf("field %s: must be >= %v", "reserve_pool_size", 0)
	}
	if v, ok := raw["server_idle_timeout"]; !ok || v == nil {
		plain.ServerIdleTimeout = "600s"
	}
	if matched, _ := regexp.MatchString(`^[0-9]+(us|ms|s|min|h|d)?$`, string(plain.ServerIdleTimeout)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "ServerIdleTimeout", `^[0-9]+(us|ms|s|min|h|d)?$`)
	}
	if v, ok := raw["server_lifetime"]; !ok || v == nil {
		plain.ServerLifetime = "3600s"
	}
	if matched, _ := regexp.MatchString(`^[0-9]+(us|ms|s|min|h|d)?$`, string(plain.ServerLifetime)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "ServerLifetime", `^[0-9]+(us|ms|s|min|h|d)?$`)
	}
	if v, ok := raw["server_reset_query"]; !ok || v == nil {
		plain.ServerResetQuery = "DISCARD ALL"
	}
	*j = PgBouncerConf(plain)
	return nil
}

type PgconfigSchemaJson struct {
	// Pgaudit corresponds to the JSON schema field "pgaudit".
	Pgaudit *PGAuditConf `json:"pgaudit,omitempty" yaml:"pgaudit,omitempty" mapstructure:"pgaudit,omitempty"`

	// Pgbouncer corresponds to the JSON schema field "pgbouncer".
	Pgbouncer *PgBouncerConf `json:"pgbouncer,omitempty" yaml:"pgbouncer,omitempty" mapstructure:"pgbouncer,omitempty"`

	// Postgres corresponds to the JSON schema field "postgres".
	Postgres *PostgresConf `json:"postgres,omitempty" yaml:"postgres,omitempty" mapstructure:"postgres,omitempty"`

	// Postgrest corresponds to the JSON schema field "postgrest".
	Postgrest *PostgrestConf `json:"postgrest,omitempty" yaml:"postgrest,omitempty" mapstructure:"postgrest,omitempty"`

	// Walg corresponds to the JSON schema field "walg".
	Walg *WalgConf `json:"walg,omitempty" yaml:"walg,omitempty" mapstructure:"walg,omitempty"`
}

// Main PostgreSQL server configuration
type PostgresConf struct {
	// Sets the host name or IP address(es) to listen to.
	ListenAddresses string `json:"listen_addresses,omitempty" yaml:"listen_addresses,omitempty" mapstructure:"listen_addresses,omitempty"`

	// Sets the maximum number of concurrent connections.
	MaxConnections int `json:"max_connections,omitempty" yaml:"max_connections,omitempty" mapstructure:"max_connections,omitempty"`

	// Sets the TCP port the server listens on.
	Port int `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`

	// Sets the number of shared memory buffers used by the server.
	SharedBuffers types.Size `json:"shared_buffers,omitempty" yaml:"shared_buffers,omitempty" mapstructure:"shared_buffers,omitempty"`

	// Sets the superuser password.
	SuperuserPassword *string `json:"superuser_password,omitempty" yaml:"superuser_password,omitempty" mapstructure:"superuser_password,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PostgresConf) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain PostgresConf
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["listen_addresses"]; !ok || v == nil {
		plain.ListenAddresses = "localhost"
	}
	if v, ok := raw["max_connections"]; !ok || v == nil {
		plain.MaxConnections = 100.0
	}
	if 262143 < plain.MaxConnections {
		return fmt.Errorf("field %s: must be <= %v", "max_connections", 262143)
	}
	if 1 > plain.MaxConnections {
		return fmt.Errorf("field %s: must be >= %v", "max_connections", 1)
	}
	if v, ok := raw["port"]; !ok || v == nil {
		plain.Port = 5432.0
	}
	if 65535 < plain.Port {
		return fmt.Errorf("field %s: must be <= %v", "port", 65535)
	}
	if 1 > plain.Port {
		return fmt.Errorf("field %s: must be >= %v", "port", 1)
	}
	if v, ok := raw["shared_buffers"]; !ok || v == nil {
		plain.SharedBuffers = types.NewSize("128MB")
	}
	if matched, _ := regexp.MatchString(`^[0-9]+[kMGT]?B?$`, string(plain.SharedBuffers)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "SharedBuffers", `^[0-9]+[kMGT]?B?$`)
	}
	*j = PostgresConf(plain)
	return nil
}

// PostgREST API server configuration
type PostgrestConf struct {
	// Database role with admin privileges
	AdminRole string `json:"admin_role,omitempty" yaml:"admin_role,omitempty" mapstructure:"admin_role,omitempty"`

	// Database role for anonymous access
	AnonymousRole string `json:"anonymous_role,omitempty" yaml:"anonymous_role,omitempty" mapstructure:"anonymous_role,omitempty"`

	// Database connection pool size
	DbPool int `json:"db_pool,omitempty" yaml:"db_pool,omitempty" mapstructure:"db_pool,omitempty"`

	// Database connection pool timeout in seconds
	DbPoolTimeout int `json:"db_pool_timeout,omitempty" yaml:"db_pool_timeout,omitempty" mapstructure:"db_pool_timeout,omitempty"`

	// Database schemas to expose via API
	DbSchemas string `json:"db_schemas,omitempty" yaml:"db_schemas,omitempty" mapstructure:"db_schemas,omitempty"`

	// Database connection URI
	DbUri *string `json:"db_uri,omitempty" yaml:"db_uri,omitempty" mapstructure:"db_uri,omitempty"`

	// JWT audience claim
	JwtAud string `json:"jwt_aud,omitempty" yaml:"jwt_aud,omitempty" mapstructure:"jwt_aud,omitempty"`

	// JWT secret for authentication
	JwtSecret *string `json:"jwt_secret,omitempty" yaml:"jwt_secret,omitempty" mapstructure:"jwt_secret,omitempty"`

	// Whether JWT secret is base64 encoded
	JwtSecretIsBase64 bool `json:"jwt_secret_is_base64,omitempty" yaml:"jwt_secret_is_base64,omitempty" mapstructure:"jwt_secret_is_base64,omitempty"`

	// Logging level
	LogLevel PostgrestConfLogLevel `json:"log_level,omitempty" yaml:"log_level,omitempty" mapstructure:"log_level,omitempty"`

	// Maximum rows returned in a single response
	MaxRows *int `json:"max_rows,omitempty" yaml:"max_rows,omitempty" mapstructure:"max_rows,omitempty"`

	// Pre-request function to call
	PreRequest string `json:"pre_request,omitempty" yaml:"pre_request,omitempty" mapstructure:"pre_request,omitempty"`

	// JWT claim key for role
	RoleClaimKey string `json:"role_claim_key,omitempty" yaml:"role_claim_key,omitempty" mapstructure:"role_claim_key,omitempty"`

	// Server host address
	ServerHost string `json:"server_host,omitempty" yaml:"server_host,omitempty" mapstructure:"server_host,omitempty"`

	// Server port
	ServerPort int `json:"server_port,omitempty" yaml:"server_port,omitempty" mapstructure:"server_port,omitempty"`

	// Path to SSL certificate file
	ServerSslCert string `json:"server_ssl_cert,omitempty" yaml:"server_ssl_cert,omitempty" mapstructure:"server_ssl_cert,omitempty"`

	// Path to SSL private key file
	ServerSslKey string `json:"server_ssl_key,omitempty" yaml:"server_ssl_key,omitempty" mapstructure:"server_ssl_key,omitempty"`
}

type PostgrestConfLogLevel string

const PostgrestConfLogLevelCrit PostgrestConfLogLevel = "crit"
const PostgrestConfLogLevelDebug PostgrestConfLogLevel = "debug"
const PostgrestConfLogLevelError PostgrestConfLogLevel = "error"
const PostgrestConfLogLevelInfo PostgrestConfLogLevel = "info"
const PostgrestConfLogLevelWarn PostgrestConfLogLevel = "warn"

var enumValues_PostgrestConfLogLevel = []interface{}{
	"crit",
	"error",
	"warn",
	"info",
	"debug",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PostgrestConfLogLevel) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PostgrestConfLogLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PostgrestConfLogLevel, v)
	}
	*j = PostgrestConfLogLevel(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PostgrestConf) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain PostgrestConf
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["admin_role"]; !ok || v == nil {
		plain.AdminRole = "postgres"
	}
	if v, ok := raw["anonymous_role"]; !ok || v == nil {
		plain.AnonymousRole = "anon"
	}
	if v, ok := raw["db_pool"]; !ok || v == nil {
		plain.DbPool = 10.0
	}
	if 1000 < plain.DbPool {
		return fmt.Errorf("field %s: must be <= %v", "db_pool", 1000)
	}
	if 1 > plain.DbPool {
		return fmt.Errorf("field %s: must be >= %v", "db_pool", 1)
	}
	if v, ok := raw["db_pool_timeout"]; !ok || v == nil {
		plain.DbPoolTimeout = 10.0
	}
	if 1 > plain.DbPoolTimeout {
		return fmt.Errorf("field %s: must be >= %v", "db_pool_timeout", 1)
	}
	if v, ok := raw["db_schemas"]; !ok || v == nil {
		plain.DbSchemas = "public"
	}
	if plain.DbUri != nil {
		if matched, _ := regexp.MatchString(`^postgres(ql)?://.*`, string(*plain.DbUri)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DbUri", `^postgres(ql)?://.*`)
		}
	}
	if v, ok := raw["jwt_aud"]; !ok || v == nil {
		plain.JwtAud = ""
	}
	if v, ok := raw["jwt_secret_is_base64"]; !ok || v == nil {
		plain.JwtSecretIsBase64 = false
	}
	if v, ok := raw["log_level"]; !ok || v == nil {
		plain.LogLevel = "error"
	}
	if plain.MaxRows != nil && 1 > *plain.MaxRows {
		return fmt.Errorf("field %s: must be >= %v", "max_rows", 1)
	}
	if v, ok := raw["pre_request"]; !ok || v == nil {
		plain.PreRequest = ""
	}
	if v, ok := raw["role_claim_key"]; !ok || v == nil {
		plain.RoleClaimKey = "role"
	}
	if v, ok := raw["server_host"]; !ok || v == nil {
		plain.ServerHost = "0.0.0.0"
	}
	if v, ok := raw["server_port"]; !ok || v == nil {
		plain.ServerPort = 3000.0
	}
	if 65535 < plain.ServerPort {
		return fmt.Errorf("field %s: must be <= %v", "server_port", 65535)
	}
	if 1 > plain.ServerPort {
		return fmt.Errorf("field %s: must be >= %v", "server_port", 1)
	}
	if v, ok := raw["server_ssl_cert"]; !ok || v == nil {
		plain.ServerSslCert = ""
	}
	if v, ok := raw["server_ssl_key"]; !ok || v == nil {
		plain.ServerSslKey = ""
	}
	*j = PostgrestConf(plain)
	return nil
}

// WAL-G backup and archiving configuration
type WalgConf struct {
	// Azure storage account key
	AzAccountKey *string `json:"az_account_key,omitempty" yaml:"az_account_key,omitempty" mapstructure:"az_account_key,omitempty"`

	// Azure storage account name
	AzAccountName *string `json:"az_account_name,omitempty" yaml:"az_account_name,omitempty" mapstructure:"az_account_name,omitempty"`

	// Azure Storage prefix
	AzPrefix *string `json:"az_prefix,omitempty" yaml:"az_prefix,omitempty" mapstructure:"az_prefix,omitempty"`

	// Number of backups to retain
	BackupRetainCount int `json:"backup_retain_count,omitempty" yaml:"backup_retain_count,omitempty" mapstructure:"backup_retain_count,omitempty"`

	// Backup schedule in cron format
	BackupSchedule string `json:"backup_schedule,omitempty" yaml:"backup_schedule,omitempty" mapstructure:"backup_schedule,omitempty"`

	// Compression level (0-9)
	CompressionLevel int `json:"compression_level,omitempty" yaml:"compression_level,omitempty" mapstructure:"compression_level,omitempty"`

	// Compression method for backups
	CompressionMethod WalgConfCompressionMethod `json:"compression_method,omitempty" yaml:"compression_method,omitempty" mapstructure:"compression_method,omitempty"`

	// Maximum steps for delta backups
	DeltaMaxSteps int `json:"delta_max_steps,omitempty" yaml:"delta_max_steps,omitempty" mapstructure:"delta_max_steps,omitempty"`

	// Enable or disable WAL-G
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Local file system prefix for backups
	FilePrefix *string `json:"file_prefix,omitempty" yaml:"file_prefix,omitempty" mapstructure:"file_prefix,omitempty"`

	// Google Cloud Storage prefix (e.g., gs://bucket/path/to/folder)
	GsPrefix *string `json:"gs_prefix,omitempty" yaml:"gs_prefix,omitempty" mapstructure:"gs_prefix,omitempty"`

	// Google Cloud project ID
	GsProjectId *string `json:"gs_project_id,omitempty" yaml:"gs_project_id,omitempty" mapstructure:"gs_project_id,omitempty"`

	// Google Cloud service account key JSON
	GsServiceAccountKey *string `json:"gs_service_account_key,omitempty" yaml:"gs_service_account_key,omitempty" mapstructure:"gs_service_account_key,omitempty"`

	// PostgreSQL data directory path
	PostgresqlDataDir string `json:"postgresql_data_dir,omitempty" yaml:"postgresql_data_dir,omitempty" mapstructure:"postgresql_data_dir,omitempty"`

	// AWS S3 access key ID
	S3AccessKey *string `json:"s3_access_key,omitempty" yaml:"s3_access_key,omitempty" mapstructure:"s3_access_key,omitempty"`

	// Custom S3 endpoint URL
	S3Endpoint *string `json:"s3_endpoint,omitempty" yaml:"s3_endpoint,omitempty" mapstructure:"s3_endpoint,omitempty"`

	// S3 storage prefix (e.g., s3://bucket/path/to/folder)
	S3Prefix *string `json:"s3_prefix,omitempty" yaml:"s3_prefix,omitempty" mapstructure:"s3_prefix,omitempty"`

	// AWS S3 region
	S3Region string `json:"s3_region,omitempty" yaml:"s3_region,omitempty" mapstructure:"s3_region,omitempty"`

	// AWS S3 secret access key
	S3SecretKey *string `json:"s3_secret_key,omitempty" yaml:"s3_secret_key,omitempty" mapstructure:"s3_secret_key,omitempty"`

	// AWS S3 session token (for temporary credentials)
	S3SessionToken *string `json:"s3_session_token,omitempty" yaml:"s3_session_token,omitempty" mapstructure:"s3_session_token,omitempty"`

	// Use SSL for S3 connections
	S3UseSsl bool `json:"s3_use_ssl,omitempty" yaml:"s3_use_ssl,omitempty" mapstructure:"s3_use_ssl,omitempty"`

	// Command to create WAL stream
	StreamCreateCommand *string `json:"stream_create_command,omitempty" yaml:"stream_create_command,omitempty" mapstructure:"stream_create_command,omitempty"`

	// Command to restore from WAL stream
	StreamRestoreCommand *string `json:"stream_restore_command,omitempty" yaml:"stream_restore_command,omitempty" mapstructure:"stream_restore_command,omitempty"`

	// Number of concurrent uploads
	UploadConcurrency int `json:"upload_concurrency,omitempty" yaml:"upload_concurrency,omitempty" mapstructure:"upload_concurrency,omitempty"`

	// Number of concurrent disk operations
	UploadDiskConcurrency int `json:"upload_disk_concurrency,omitempty" yaml:"upload_disk_concurrency,omitempty" mapstructure:"upload_disk_concurrency,omitempty"`

	// Verify WAL checksums during backup
	WalVerifyChecksum bool `json:"wal_verify_checksum,omitempty" yaml:"wal_verify_checksum,omitempty" mapstructure:"wal_verify_checksum,omitempty"`
}

type WalgConfCompressionMethod string

const WalgConfCompressionMethodBrotli WalgConfCompressionMethod = "brotli"
const WalgConfCompressionMethodLz4 WalgConfCompressionMethod = "lz4"
const WalgConfCompressionMethodLzma WalgConfCompressionMethod = "lzma"
const WalgConfCompressionMethodZstd WalgConfCompressionMethod = "zstd"

var enumValues_WalgConfCompressionMethod = []interface{}{
	"lz4",
	"lzma",
	"brotli",
	"zstd",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WalgConfCompressionMethod) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WalgConfCompressionMethod {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WalgConfCompressionMethod, v)
	}
	*j = WalgConfCompressionMethod(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WalgConf) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain WalgConf
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["backup_retain_count"]; !ok || v == nil {
		plain.BackupRetainCount = 7.0
	}
	if 1 > plain.BackupRetainCount {
		return fmt.Errorf("field %s: must be >= %v", "backup_retain_count", 1)
	}
	if v, ok := raw["backup_schedule"]; !ok || v == nil {
		plain.BackupSchedule = "0 2 * * *"
	}
	if v, ok := raw["compression_level"]; !ok || v == nil {
		plain.CompressionLevel = 1.0
	}
	if 9 < plain.CompressionLevel {
		return fmt.Errorf("field %s: must be <= %v", "compression_level", 9)
	}
	if 0 > plain.CompressionLevel {
		return fmt.Errorf("field %s: must be >= %v", "compression_level", 0)
	}
	if v, ok := raw["compression_method"]; !ok || v == nil {
		plain.CompressionMethod = "lz4"
	}
	if v, ok := raw["delta_max_steps"]; !ok || v == nil {
		plain.DeltaMaxSteps = 32.0
	}
	if 1 > plain.DeltaMaxSteps {
		return fmt.Errorf("field %s: must be >= %v", "delta_max_steps", 1)
	}
	if v, ok := raw["enabled"]; !ok || v == nil {
		plain.Enabled = false
	}
	if plain.GsPrefix != nil {
		if matched, _ := regexp.MatchString(`^gs://.*`, string(*plain.GsPrefix)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "GsPrefix", `^gs://.*`)
		}
	}
	if v, ok := raw["postgresql_data_dir"]; !ok || v == nil {
		plain.PostgresqlDataDir = "/var/lib/postgresql/data"
	}
	if plain.S3Prefix != nil {
		if matched, _ := regexp.MatchString(`^s3://.*`, string(*plain.S3Prefix)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "S3Prefix", `^s3://.*`)
		}
	}
	if v, ok := raw["s3_region"]; !ok || v == nil {
		plain.S3Region = "us-east-1"
	}
	if v, ok := raw["s3_use_ssl"]; !ok || v == nil {
		plain.S3UseSsl = true
	}
	if v, ok := raw["upload_concurrency"]; !ok || v == nil {
		plain.UploadConcurrency = 16.0
	}
	if 100 < plain.UploadConcurrency {
		return fmt.Errorf("field %s: must be <= %v", "upload_concurrency", 100)
	}
	if 1 > plain.UploadConcurrency {
		return fmt.Errorf("field %s: must be >= %v", "upload_concurrency", 1)
	}
	if v, ok := raw["upload_disk_concurrency"]; !ok || v == nil {
		plain.UploadDiskConcurrency = 1.0
	}
	if 100 < plain.UploadDiskConcurrency {
		return fmt.Errorf("field %s: must be <= %v", "upload_disk_concurrency", 100)
	}
	if 1 > plain.UploadDiskConcurrency {
		return fmt.Errorf("field %s: must be >= %v", "upload_disk_concurrency", 1)
	}
	if v, ok := raw["wal_verify_checksum"]; !ok || v == nil {
		plain.WalVerifyChecksum = true
	}
	*j = WalgConf(plain)
	return nil
}
